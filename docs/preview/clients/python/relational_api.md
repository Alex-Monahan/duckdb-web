---
layout: docu
redirect_from:
- /docs/api/python/relational_api
- /docs/api/python/relational_api/
- /docs/clients/python/relational_api
title: Relational API
---

<!-- Generated by scripts/generate_python_relational_docs.py -->


## Index

**[Relation Creation](#relation-creation)**

| Name | Description |
|:--|:-------|
| [`from_arrow`](#from_arrow) | Create a relation object from an Arrow object |
| [`from_csv_auto`](#from_csv_auto) | Create a relation object from the CSV file in 'name' |
| [`from_df`](#from_df) | Create a relation object from the DataFrame in df |
| [`from_parquet`](#from_parquet) | Create a relation object from the Parquet files |
| [`from_query`](#from_query) | Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise run the query as-is. |
| [`query`](#query) | Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise run the query as-is. |
| [`read_csv`](#read_csv) | Create a relation object from the CSV file in 'name' |
| [`read_json`](#read_json) | Create a relation object from the JSON file in 'name' |
| [`read_parquet`](#read_parquet) | Create a relation object from the Parquet files |
| [`sql`](#sql) | Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise run the query as-is. |
| [`table`](#table) | Create a relation object for the named table |
| [`table_function`](#table_function) | Create a relation object from the named table function with given parameters |
| [`values`](#values) | Create a relation object from the passed values |
| [`view`](#view) | Create a relation object for the named view |

**[Relation Definition Details](#relation-definition-details)**

| Name | Description |
|:--|:-------|
| [`alias`](#alias) | Get the name of the current alias |
| [`columns`](#columns) | Return a list containing the names of the columns of the relation. |
| [`describe`](#describe) | Gives basic statistics (e.g., min, max) and if NULL exists for each column of the relation. |
| [`description`](#description) | Return the description of the result |
| [`dtypes`](#dtypes) | Return a list containing the types of the columns of the relation. |
| [`explain`](#explain) | explain(self: duckdb.duckdb.DuckDBPyRelation, type: duckdb.duckdb.ExplainType = 'standard') -> str |
| [`query`](#query) | Run the given SQL query in sql_query on the view named virtual_table_name that refers to the relation object |
| [`set_alias`](#set_alias) | Rename the relation object to new alias |
| [`shape`](#shape) | Tuple of # of rows, # of columns in relation. |
| [`show`](#show) | Display a summary of the data |
| [`sql_query`](#sql_query) | Get the SQL query that is equivalent to the relation |
| [`type`](#type) | Get the type of the relation. |
| [`types`](#types) | Return a list containing the types of the columns of the relation. |

**[Transformation](#transformation)**

| Name | Description |
|:--|:-------|
| [`aggregate`](#aggregate) | Compute the aggregate aggr_expr by the optional groups group_expr on the relation |
| [`apply`](#apply) | Compute the function of a single column or a list of columns by the optional groups on the relation |
| [`cross`](#cross) | Create cross/cartesian product of two relational objects |
| [`except_`](#except_) | Create the set except of this relation object with another relation object in other_rel |
| [`filter`](#filter) | Filter the relation object by the filter in filter_expr |
| [`insert`](#insert) | Inserts the given values into the relation |
| [`insert_into`](#insert_into) | Inserts the relation object into an existing table named table_name |
| [`intersect`](#intersect) | Create the set intersection of this relation object with another relation object in other_rel |
| [`join`](#join) | Join the relation object with another relation object in other_rel using the join condition expression in join_condition. Types supported are 'inner', 'left', 'right', 'outer', 'semi' and 'anti' |
| [`limit`](#limit) | Only retrieve the first n rows from this relation object, starting at offset |
| [`map`](#map) | Calls the passed function on the relation |
| [`order`](#order) | Reorder the relation object by order_expr |
| [`project`](#project) | Project the relation object by the projection in project_expr |
| [`select`](#select) | Project the relation object by the projection in project_expr |
| [`sort`](#sort) | Reorder the relation object by the provided expressions |
| [`union`](#union) | Create the set union of this relation object with another relation object in other_rel |
| [`update`](#update) | Update the given relation with the provided expressions |

**[Functions](#functions)**

| Name | Description |
|:--|:-------|
| [`any_value`](#any_value) | Returns the first non-null value from a given column |
| [`arg_max`](#arg_max) | Finds the row with the maximum value for a value column and returns the value of that row for an argument column |
| [`arg_min`](#arg_min) | Finds the row with the minimum value for a value column and returns the value of that row for an argument column |
| [`avg`](#avg) | Computes the average on a given column |
| [`bit_and`](#bit_and) | Computes the bitwise AND of all bits present in a given column |
| [`bit_or`](#bit_or) | Computes the bitwise OR of all bits present in a given column |
| [`bit_xor`](#bit_xor) | Computes the bitwise XOR of all bits present in a given column |
| [`bitstring_agg`](#bitstring_agg) | Computes a bitstring with bits set for each distinct value in a given column |
| [`bool_and`](#bool_and) | Computes the logical AND of all values present in a given column |
| [`bool_or`](#bool_or) | Computes the logical OR of all values present in a given column |
| [`count`](#count) | Computes the number of elements present in a given column |
| [`cume_dist`](#cume_dist) | Computes the cumulative distribution within the partition |
| [`dense_rank`](#dense_rank) | Computes the dense rank within the partition |
| [`distinct`](#distinct) | Retrieve distinct rows from this relation object |
| [`favg`](#favg) | Computes the average of all values present in a given column using a more accurate floating point summation (Kahan Sum) |
| [`first`](#first) | Returns the first value of a given column |
| [`first_value`](#first_value) | Computes the first value within the group or partition |
| [`fsum`](#fsum) | Computes the sum of all values present in a given column using a more accurate floating point summation (Kahan Sum) |
| [`geomean`](#geomean) | Computes the geometric mean over all values present in a given column |
| [`histogram`](#histogram) | Computes the histogram over all values present in a given column |
| [`lag`](#lag) | Computes the lag within the partition |
| [`last`](#last) | Returns the last value of a given column |
| [`last_value`](#last_value) | Computes the last value within the group or partition |
| [`lead`](#lead) | Computes the lead within the partition |
| [`list`](#list) | Returns a list containing all values present in a given column |
| [`max`](#max) | Returns the maximum value present in a given column |
| [`mean`](#mean) | Computes the average on a given column |
| [`median`](#median) | Computes the median over all values present in a given column |
| [`min`](#min) | Returns the minimum value present in a given column |
| [`mode`](#mode) | Computes the mode over all values present in a given column |
| [`n_tile`](#n_tile) | Divides the partition as equally as possible into num_buckets |
| [`nth_value`](#nth_value) | Computes the nth value within the partition |
| [`percent_rank`](#percent_rank) | Computes the relative rank within the partition |
| [`product`](#product) | Returns the product of all values present in a given column |
| [`quantile`](#quantile) | Computes the exact quantile value for a given column |
| [`quantile_cont`](#quantile_cont) | Computes the interpolated quantile value for a given column |
| [`quantile_disc`](#quantile_disc) | Computes the exact quantile value for a given column |
| [`rank`](#rank) | Computes the rank within the partition |
| [`rank_dense`](#rank_dense) | Computes the dense rank within the partition |
| [`row_number`](#row_number) | Computes the row number within the partition |
| [`select_dtypes`](#select_dtypes) | Select columns from the relation, by filtering based on type(s) |
| [`select_types`](#select_types) | Select columns from the relation, by filtering based on type(s) |
| [`std`](#std) | Computes the sample standard deviation for a given column |
| [`stddev`](#stddev) | Computes the sample standard deviation for a given column |
| [`stddev_pop`](#stddev_pop) | Computes the population standard deviation for a given column |
| [`stddev_samp`](#stddev_samp) | Computes the sample standard deviation for a given column |
| [`string_agg`](#string_agg) | Concatenates the values present in a given column with a separator |
| [`sum`](#sum) | Computes the sum of all values present in a given column |
| [`unique`](#unique) | Returns the distinct values in a column. |
| [`value_counts`](#value_counts) | Computes the number of elements present in a given column, also projecting the original column |
| [`var`](#var) | Computes the sample variance for a given column |
| [`var_pop`](#var_pop) | Computes the population variance for a given column |
| [`var_samp`](#var_samp) | Computes the sample variance for a given column |
| [`variance`](#variance) | Computes the sample variance for a given column |

**[Output](#output)**

| Name | Description |
|:--|:-------|
| [`arrow`](#arrow) | Execute and fetch all rows as an Arrow Table |
| [`close`](#close) | Closes the result |
| [`create`](#create) | Creates a new table named table_name with the contents of the relation object |
| [`create_view`](#create_view) | Creates a view named view_name that refers to the relation object |
| [`df`](#df) | Execute and fetch all rows as a pandas DataFrame |
| [`execute`](#execute) | Transform the relation into a result set |
| [`fetch_arrow_reader`](#fetch_arrow_reader) | Execute and return an Arrow Record Batch Reader that yields all rows |
| [`fetch_arrow_table`](#fetch_arrow_table) | Execute and fetch all rows as an Arrow Table |
| [`fetch_df_chunk`](#fetch_df_chunk) | Execute and fetch a chunk of the rows |
| [`fetchall`](#fetchall) | Execute and fetch all rows as a list of tuples |
| [`fetchdf`](#fetchdf) | Execute and fetch all rows as a pandas DataFrame |
| [`fetchmany`](#fetchmany) | Execute and fetch the next set of rows as a list of tuples |
| [`fetchnumpy`](#fetchnumpy) | Execute and fetch all rows as a Python dict mapping each column to one numpy arrays |
| [`fetchone`](#fetchone) | Execute and fetch a single row as a tuple |
| [`pl`](#pl) | Execute and fetch all rows as a Polars DataFrame |
| [`record_batch`](#record_batch) | Execute and return an Arrow Record Batch Reader that yields all rows |
| [`tf`](#tf) | Fetch a result as dict of TensorFlow Tensors |
| [`to_arrow_table`](#to_arrow_table) | Execute and fetch all rows as an Arrow Table |
| [`to_csv`](#to_csv) | Write the relation object to a CSV file in 'file_name' |
| [`to_df`](#to_df) | Execute and fetch all rows as a pandas DataFrame |
| [`to_parquet`](#to_parquet) | Write the relation object to a Parquet file in 'file_name' |
| [`to_table`](#to_table) | Creates a new table named table_name with the contents of the relation object |
| [`to_view`](#to_view) | Creates a view named view_name that refers to the relation object |
| [`torch`](#torch) | Fetch a result as dict of PyTorch Tensors |
| [`write_csv`](#write_csv) | Write the relation object to a CSV file in 'file_name' |
| [`write_parquet`](#write_parquet) | Write the relation object to a Parquet file in 'file_name' |



## Relation Creation 

This section contains the details on how a relation is created.

### from_arrow

#### Description

Create a relation object from an Arrow object

#### Signature

```python
 from_arrow(self: duckdb.duckdb.DuckDBPyConnection, arrow_object: object) -> duckdb.duckdb.DuckDBPyRelation
```

----

### from_csv_auto

#### Description

Create a relation object from the CSV file in 'name'

#### Signature

```python
 from_csv_auto(self: duckdb.duckdb.DuckDBPyConnection, path_or_buffer: object, **kwargs) -> duckdb.duckdb.DuckDBPyRelation
```

----

### from_df

#### Description

Create a relation object from the DataFrame in df

#### Signature

```python
 from_df(self: duckdb.duckdb.DuckDBPyConnection, df: pandas.DataFrame) -> duckdb.duckdb.DuckDBPyRelation
```

----

### from_parquet

#### Description

Create a relation object from the Parquet files

#### Signature

```python
 from_parquet(*args, **kwargs)
Overloaded function.
```

----

### from_query

#### Description

Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise run the query as-is.

#### Signature

```python
 from_query(self: duckdb.duckdb.DuckDBPyConnection, query: object, *, alias: str = '', params: object = None) -> duckdb.duckdb.DuckDBPyRelation
```

----

### query

#### Description

Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise run the query as-is.

#### Signature

```python
 query(self: duckdb.duckdb.DuckDBPyConnection, query: object, *, alias: str = '', params: object = None) -> duckdb.duckdb.DuckDBPyRelation
```

----

### read_csv

#### Description

Create a relation object from the CSV file in 'name'

#### Signature

```python
 read_csv(self: duckdb.duckdb.DuckDBPyConnection, path_or_buffer: object, **kwargs) -> duckdb.duckdb.DuckDBPyRelation
```

----

### read_json

#### Description

Create a relation object from the JSON file in 'name'

#### Signature

```python
 read_json(self: duckdb.duckdb.DuckDBPyConnection, path_or_buffer: object, *, columns: typing.Optional[object] = None, sample_size: typing.Optional[object] = None, maximum_depth: typing.Optional[object] = None, records: typing.Optional[str] = None, format: typing.Optional[str] = None, date_format: typing.Optional[object] = None, timestamp_format: typing.Optional[object] = None, compression: typing.Optional[object] = None, maximum_object_size: typing.Optional[object] = None, ignore_errors: typing.Optional[object] = None, convert_strings_to_integers: typing.Optional[object] = None, field_appearance_threshold: typing.Optional[object] = None, map_inference_threshold: typing.Optional[object] = None, maximum_sample_files: typing.Optional[object] = None, filename: typing.Optional[object] = None, hive_partitioning: typing.Optional[object] = None, union_by_name: typing.Optional[object] = None, hive_types: typing.Optional[object] = None, hive_types_autocast: typing.Optional[object] = None) -> duckdb.duckdb.DuckDBPyRelation
```

----

### read_parquet

#### Description

Create a relation object from the Parquet files

#### Signature

```python
 read_parquet(*args, **kwargs)
Overloaded function.
```

----

### sql

#### Description

Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise run the query as-is.

#### Signature

```python
 sql(self: duckdb.duckdb.DuckDBPyConnection, query: object, *, alias: str = '', params: object = None) -> duckdb.duckdb.DuckDBPyRelation
```

----

### table

#### Description

Create a relation object for the named table

#### Signature

```python
 table(self: duckdb.duckdb.DuckDBPyConnection, table_name: str) -> duckdb.duckdb.DuckDBPyRelation
```

----

### table_function

#### Description

Create a relation object from the named table function with given parameters

#### Signature

```python
 table_function(self: duckdb.duckdb.DuckDBPyConnection, name: str, parameters: object = None) -> duckdb.duckdb.DuckDBPyRelation
```

----

### values

#### Description

Create a relation object from the passed values

#### Signature

```python
 values(self: duckdb.duckdb.DuckDBPyConnection, *args) -> duckdb.duckdb.DuckDBPyRelation
```

----

### view

#### Description

Create a relation object for the named view

#### Signature

```python
 view(self: duckdb.duckdb.DuckDBPyConnection, view_name: str) -> duckdb.duckdb.DuckDBPyRelation
```

## Relation Definition Details 

This section contains the details on how to inspect a relation.

### alias

#### Description

Get the name of the current alias

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.alias
```


##### Result

```text
unnamed_relation_43c808c247431be5
```

----

### columns

#### Description

Return a list containing the names of the columns of the relation.

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.columns
```


##### Result

```text
 ['id', 'description', 'value', 'created_timestamp']
```

----

### describe

#### Description

Gives basic statistics (e.g., min, max) and if NULL exists for each column of the relation.

#### Signature

```python
 describe(self: duckdb.duckdb.DuckDBPyRelation) -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.describe()
```


##### Result

```text

┌─────────┬──────────────────────────────────────┬─────────────────┬────────────────────┬────────────────────────────┐
│  aggr   │                  id                  │   description   │       value        │     created_timestamp      │
│ varchar │               varchar                │     varchar     │       double       │          varchar           │
├─────────┼──────────────────────────────────────┼─────────────────┼────────────────────┼────────────────────────────┤
│ count   │ 9                                    │ 9               │                9.0 │ 9                          │
│ mean    │ NULL                                 │ NULL            │                5.0 │ NULL                       │
│ stddev  │ NULL                                 │ NULL            │ 2.7386127875258306 │ NULL                       │
│ min     │ 08fdcbf8-4e53-4290-9e81-423af263b518 │ value is even   │                1.0 │ 2025-04-09 15:41:20.642+02 │
│ max     │ fb10390e-fad5-4694-91cb-e82728cb6f9f │ value is uneven │                9.0 │ 2025-04-09 15:49:20.642+02 │
│ median  │ NULL                                 │ NULL            │                5.0 │ NULL                       │
└─────────┴──────────────────────────────────────┴─────────────────┴────────────────────┴────────────────────────────┘ 

```

----

### description

#### Description

Return the description of the result

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.description
```


##### Result

```text

[('id', 'UUID', None, None, None, None, None),
 ('description', 'STRING', None, None, None, None, None),
 ('value', 'NUMBER', None, None, None, None, None),
 ('created_timestamp', 'DATETIME', None, None, None, None, None)]  

```

----

### dtypes

#### Description

Return a list containing the types of the columns of the relation.

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.dtypes
```


##### Result

```text
 [UUID, VARCHAR, BIGINT, TIMESTAMP WITH TIME ZONE]
```

----

### explain

#### Description

explain(self: duckdb.duckdb.DuckDBPyRelation, type: duckdb.duckdb.ExplainType = 'standard') -> str

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.explain()
```


##### Result

```text

┌───────────────────────────┐
│         SEQ_SCAN          │
│    ────────────────────   │
│    Table: code_example    │
│   Type: Sequential Scan   │
│                           │
│        Projections:       │
│             id            │
│        description        │
│           value           │
│     created_timestamp     │
│                           │
│          ~9 Rows          │
└───────────────────────────┘



```

----

### query

#### Description

Run the given SQL query in sql_query on the view named virtual_table_name that refers to the relation object

#### Signature

```python
 query(self: duckdb.duckdb.DuckDBPyRelation, virtual_table_name: str, sql_query: str) -> duckdb.duckdb.DuckDBPyRelation
```

----

### set_alias

#### Description

Rename the relation object to new alias

#### Signature

```python
 set_alias(self: duckdb.duckdb.DuckDBPyRelation, alias: str) -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.set_alias('abc').select('abc.id')
```


##### Result

```text
In the SQL query, the alias will be `abc`
```

----

### shape

#### Description

Tuple of # of rows, # of columns in relation.

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.shape
```


##### Result

```text
(9, 4)
```

----

### show

#### Description

Display a summary of the data

#### Signature

```python
 show(self: duckdb.duckdb.DuckDBPyRelation, *, max_width: typing.Optional[int] = None, max_rows: typing.Optional[int] = None, max_col_width: typing.Optional[int] = None, null_value: typing.Optional[str] = None, render_mode: object = None) -> None
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.show()
```


##### Result

```text

┌──────────────────────────────────────┬─────────────────┬───────┬────────────────────────────┐
│                  id                  │   description   │ value │     created_timestamp      │
│                 uuid                 │     varchar     │ int64 │  timestamp with time zone  │
├──────────────────────────────────────┼─────────────────┼───────┼────────────────────────────┤
│ 642ea3d7-793d-4867-a759-91c1226c25a0 │ value is uneven │     1 │ 2025-04-09 15:41:20.642+02 │
│ 6817dd31-297c-40a8-8e40-8521f00b2d08 │ value is even   │     2 │ 2025-04-09 15:42:20.642+02 │
│ 45143f9a-e16e-4e59-91b2-3a0800eed6d6 │ value is uneven │     3 │ 2025-04-09 15:43:20.642+02 │
│ fb10390e-fad5-4694-91cb-e82728cb6f9f │ value is even   │     4 │ 2025-04-09 15:44:20.642+02 │
│ 111ced5c-9155-418e-b087-c331b814db90 │ value is uneven │     5 │ 2025-04-09 15:45:20.642+02 │
│ 66a870a6-aef0-4085-87d5-5d1b35d21c66 │ value is even   │     6 │ 2025-04-09 15:46:20.642+02 │
│ a7e8e796-bca0-44cd-a269-1d71090fb5cc │ value is uneven │     7 │ 2025-04-09 15:47:20.642+02 │
│ 74908d48-7f2d-4bdd-9c92-1e7920b115b5 │ value is even   │     8 │ 2025-04-09 15:48:20.642+02 │
│ 08fdcbf8-4e53-4290-9e81-423af263b518 │ value is uneven │     9 │ 2025-04-09 15:49:20.642+02 │
└──────────────────────────────────────┴─────────────────┴───────┴────────────────────────────┘

```

----

### sql_query

#### Description

Get the SQL query that is equivalent to the relation

#### Signature

```python
 sql_query(self: duckdb.duckdb.DuckDBPyRelation) -> str
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.sql_query()
```


##### Result

```text
SELECT * FROM main.code_example
```

----

### type

#### Description

Get the type of the relation.

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.type
```


##### Result

```text
QUERY_RELATION
```

----

### types

#### Description

Return a list containing the types of the columns of the relation.

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.types
```


##### Result

```text
[UUID, VARCHAR, BIGINT, TIMESTAMP WITH TIME ZONE]
```

## Transformation 

This section contains the methods which can be used to chain queries.        The transformation methods are lazy evaluated, therefore not executed.        The execution happens at [output](#output) or [function](#functions) call.

### aggregate

#### Description

Compute the aggregate aggr_expr by the optional groups group_expr on the relation

#### Signature

```python
 aggregate(self: duckdb.duckdb.DuckDBPyRelation, aggr_expr: object, group_expr: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

print(rel.aggregate('max(value)'))
```


##### Result

```text

┌──────────────┐
│ max("value") │
│    int64     │
├──────────────┤
│            9 │
└──────────────┘
        
```

----

### apply

#### Description

Compute the function of a single column or a list of columns by the optional groups on the relation

#### Signature

```python
 apply(self: duckdb.duckdb.DuckDBPyRelation, function_name: str, function_aggr: str, group_expr: str = '', function_parameter: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

----

### cross

#### Description

Create cross/cartesian product of two relational objects

#### Signature

```python
 cross(self: duckdb.duckdb.DuckDBPyRelation, other_rel: duckdb.duckdb.DuckDBPyRelation) -> duckdb.duckdb.DuckDBPyRelation
```

----

### except_

#### Description

Create the set except of this relation object with another relation object in other_rel

#### Signature

```python
 except_(self: duckdb.duckdb.DuckDBPyRelation, other_rel: duckdb.duckdb.DuckDBPyRelation) -> duckdb.duckdb.DuckDBPyRelation
```

----

### filter

#### Description

Filter the relation object by the filter in filter_expr

#### Signature

```python
 filter(self: duckdb.duckdb.DuckDBPyRelation, filter_expr: object) -> duckdb.duckdb.DuckDBPyRelation
```

----

### insert

#### Description

Inserts the given values into the relation

#### Signature

```python
 insert(self: duckdb.duckdb.DuckDBPyRelation, values: object) -> None
```

----

### insert_into

#### Description

Inserts the relation object into an existing table named table_name

#### Signature

```python
 insert_into(self: duckdb.duckdb.DuckDBPyRelation, table_name: str) -> None
```

----

### intersect

#### Description

Create the set intersection of this relation object with another relation object in other_rel

#### Signature

```python
 intersect(self: duckdb.duckdb.DuckDBPyRelation, other_rel: duckdb.duckdb.DuckDBPyRelation) -> duckdb.duckdb.DuckDBPyRelation
```

----

### join

#### Description

Join the relation object with another relation object in other_rel using the join condition expression in join_condition. Types supported are 'inner', 'left', 'right', 'outer', 'semi' and 'anti'

#### Signature

```python
 join(self: duckdb.duckdb.DuckDBPyRelation, other_rel: duckdb.duckdb.DuckDBPyRelation, condition: object, how: str = 'inner') -> duckdb.duckdb.DuckDBPyRelation
```

----

### limit

#### Description

Only retrieve the first n rows from this relation object, starting at offset

#### Signature

```python
 limit(self: duckdb.duckdb.DuckDBPyRelation, n: int, offset: int = 0) -> duckdb.duckdb.DuckDBPyRelation
```

----

### map

#### Description

Calls the passed function on the relation

#### Signature

```python
 map(self: duckdb.duckdb.DuckDBPyRelation, map_function: Callable, *, schema: typing.Optional[object] = None) -> duckdb.duckdb.DuckDBPyRelation
```

----

### order

#### Description

Reorder the relation object by order_expr

#### Signature

```python
 order(self: duckdb.duckdb.DuckDBPyRelation, order_expr: str) -> duckdb.duckdb.DuckDBPyRelation
```

----

### project

#### Description

Project the relation object by the projection in project_expr

#### Signature

```python
 project(self: duckdb.duckdb.DuckDBPyRelation, *args, groups: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

----

### select

#### Description

Project the relation object by the projection in project_expr

#### Signature

```python
 select(self: duckdb.duckdb.DuckDBPyRelation, *args, groups: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

----

### sort

#### Description

Reorder the relation object by the provided expressions

#### Signature

```python
 sort(self: duckdb.duckdb.DuckDBPyRelation, *args) -> duckdb.duckdb.DuckDBPyRelation
```

----

### union

#### Description

Create the set union of this relation object with another relation object in other_rel

#### Signature

```python
 union(self: duckdb.duckdb.DuckDBPyRelation, union_rel: duckdb.duckdb.DuckDBPyRelation) -> duckdb.duckdb.DuckDBPyRelation
```

----

### update

#### Description

Update the given relation with the provided expressions

#### Signature

```python
 update(self: duckdb.duckdb.DuckDBPyRelation, set: object, *, condition: object = None) -> None
```

## Functions 

This section contains the functions which can be applied to an relation,         in order to get a (scalar) result. When a function is called the SQL is executed.

### any_value

#### Description

Returns the first non-null value from a given column

#### Signature

```python
 any_value(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.any_value('id')
```


##### Result

```text

┌──────────────────────────────────────┐
│            any_value(id)             │
│                 uuid                 │
├──────────────────────────────────────┤
│ 642ea3d7-793d-4867-a759-91c1226c25a0 │
└──────────────────────────────────────┘

```

----

### arg_max

#### Description

Finds the row with the maximum value for a value column and returns the value of that row for an argument column

#### Signature

```python
 arg_max(self: duckdb.duckdb.DuckDBPyRelation, arg_column: str, value_column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.arg_max(arg_column="value", value_column="value", groups="description", projected_columns="description")
```


##### Result

```text

┌─────────────────┬───────────────────────────┐
│   description   │ arg_max("value", "value") │
│     varchar     │           int64           │
├─────────────────┼───────────────────────────┤
│ value is uneven │                         9 │
│ value is even   │                         8 │
└─────────────────┴───────────────────────────┘

```

----

### arg_min

#### Description

Finds the row with the minimum value for a value column and returns the value of that row for an argument column

#### Signature

```python
 arg_min(self: duckdb.duckdb.DuckDBPyRelation, arg_column: str, value_column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.arg_min(arg_column="value", value_column="value", groups="description", projected_columns="description")
```


##### Result

```text

┌─────────────────┬───────────────────────────┐
│   description   │ arg_min("value", "value") │
│     varchar     │           int64           │
├─────────────────┼───────────────────────────┤
│ value is even   │                         2 │
│ value is uneven │                         1 │
└─────────────────┴───────────────────────────┘

```

----

### avg

#### Description

Computes the average on a given column

#### Signature

```python
 avg(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.avg('value')
```


##### Result

```text

┌──────────────┐
│ avg("value") │
│    double    │
├──────────────┤
│          5.0 │
└──────────────┘
 
```

----

### bit_and

#### Description

Computes the bitwise AND of all bits present in a given column

#### Signature

```python
 bit_and(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")


rel = rel.select("description, value::bit as value_bit")

rel.bit_and(column="value_bit", groups="description", projected_columns="description")

```


##### Result

```text

┌─────────────────┬──────────────────────────────────────────────────────────────────┐
│   description   │                        bit_and(value_bit)                        │
│     varchar     │                               bit                                │
├─────────────────┼──────────────────────────────────────────────────────────────────┤
│ value is uneven │ 0000000000000000000000000000000000000000000000000000000000000001 │
│ value is even   │ 0000000000000000000000000000000000000000000000000000000000000000 │
└─────────────────┴──────────────────────────────────────────────────────────────────┘    

```

----

### bit_or

#### Description

Computes the bitwise OR of all bits present in a given column

#### Signature

```python
 bit_or(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")


rel = rel.select("description, value::bit as value_bit")

rel.bit_or(column="value_bit", groups="description", projected_columns="description")

```


##### Result

```text

┌─────────────────┬──────────────────────────────────────────────────────────────────┐
│   description   │                        bit_or(value_bit)                         │
│     varchar     │                               bit                                │
├─────────────────┼──────────────────────────────────────────────────────────────────┤
│ value is uneven │ 0000000000000000000000000000000000000000000000000000000000001111 │
│ value is even   │ 0000000000000000000000000000000000000000000000000000000000001110 │
└─────────────────┴──────────────────────────────────────────────────────────────────┘    

```

----

### bit_xor

#### Description

Computes the bitwise XOR of all bits present in a given column

#### Signature

```python
 bit_xor(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")


rel = rel.select("description, value::bit as value_bit")

rel.bit_xor(column="value_bit", groups="description", projected_columns="description")

```


##### Result

```text

┌─────────────────┬──────────────────────────────────────────────────────────────────┐
│   description   │                        bit_xor(value_bit)                        │
│     varchar     │                               bit                                │
├─────────────────┼──────────────────────────────────────────────────────────────────┤
│ value is even   │ 0000000000000000000000000000000000000000000000000000000000001000 │
│ value is uneven │ 0000000000000000000000000000000000000000000000000000000000001001 │
└─────────────────┴──────────────────────────────────────────────────────────────────┘

```

----

### bitstring_agg

#### Description

Computes a bitstring with bits set for each distinct value in a given column

#### Signature

```python
 bitstring_agg(self: duckdb.duckdb.DuckDBPyRelation, column: str, min: typing.Optional[object] = None, max: typing.Optional[object] = None, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.bitstring_agg(column="value", groups="description", projected_columns="description")
```


##### Result

```text

┌─────────────────┬────────────────────────┐
│   description   │ bitstring_agg("value") │
│     varchar     │          bit           │
├─────────────────┼────────────────────────┤
│ value is uneven │ 101010101              │
│ value is even   │ 010101010              │
└─────────────────┴────────────────────────┘

```

----

### bool_and

#### Description

Computes the logical AND of all values present in a given column

#### Signature

```python
 bool_and(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")


rel = rel.select("description, mod(value,2)::boolean as uneven")

rel.bool_and(column="uneven", groups="description", projected_columns="description")

```


##### Result

```text

┌─────────────────┬──────────────────┐
│   description   │ bool_and(uneven) │
│     varchar     │     boolean      │
├─────────────────┼──────────────────┤
│ value is even   │ false            │
│ value is uneven │ true             │
└─────────────────┴──────────────────┘

```

----

### bool_or

#### Description

Computes the logical OR of all values present in a given column

#### Signature

```python
 bool_or(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")


rel = rel.select("description, mod(value,2)::boolean as uneven")

rel.bool_or(column="uneven", groups="description", projected_columns="description")

```


##### Result

```text

┌─────────────────┬─────────────────┐
│   description   │ bool_or(uneven) │
│     varchar     │     boolean     │
├─────────────────┼─────────────────┤
│ value is even   │ false           │
│ value is uneven │ true            │
└─────────────────┴─────────────────┘                

```

----

### count

#### Description

Computes the number of elements present in a given column

#### Signature

```python
 count(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.count()
```


##### Result

```text

```

----

### cume_dist

#### Description

Computes the cumulative distribution within the partition

#### Signature

```python
 cume_dist(self: duckdb.duckdb.DuckDBPyRelation, window_spec: str, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.cume_dist()
```


##### Result

```text

```

----

### dense_rank

#### Description

Computes the dense rank within the partition

#### Signature

```python
 dense_rank(self: duckdb.duckdb.DuckDBPyRelation, window_spec: str, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.dense_rank()
```


##### Result

```text

```

----

### distinct

#### Description

Retrieve distinct rows from this relation object

#### Signature

```python
 distinct(self: duckdb.duckdb.DuckDBPyRelation) -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.distinct()
```


##### Result

```text

```

----

### favg

#### Description

Computes the average of all values present in a given column using a more accurate floating point summation (Kahan Sum)

#### Signature

```python
 favg(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.favg()
```


##### Result

```text

```

----

### first

#### Description

Returns the first value of a given column

#### Signature

```python
 first(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.first()
```


##### Result

```text

```

----

### first_value

#### Description

Computes the first value within the group or partition

#### Signature

```python
 first_value(self: duckdb.duckdb.DuckDBPyRelation, column: str, window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.first_value()
```


##### Result

```text

```

----

### fsum

#### Description

Computes the sum of all values present in a given column using a more accurate floating point summation (Kahan Sum)

#### Signature

```python
 fsum(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.fsum()
```


##### Result

```text

```

----

### geomean

#### Description

Computes the geometric mean over all values present in a given column

#### Signature

```python
 geomean(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.geomean()
```


##### Result

```text

```

----

### histogram

#### Description

Computes the histogram over all values present in a given column

#### Signature

```python
 histogram(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.histogram()
```


##### Result

```text

```

----

### lag

#### Description

Computes the lag within the partition

#### Signature

```python
 lag(self: duckdb.duckdb.DuckDBPyRelation, column: str, window_spec: str, offset: int = 1, default_value: str = 'NULL', ignore_nulls: bool = False, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.lag()
```


##### Result

```text

```

----

### last

#### Description

Returns the last value of a given column

#### Signature

```python
 last(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.last()
```


##### Result

```text

```

----

### last_value

#### Description

Computes the last value within the group or partition

#### Signature

```python
 last_value(self: duckdb.duckdb.DuckDBPyRelation, column: str, window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.last_value()
```


##### Result

```text

```

----

### lead

#### Description

Computes the lead within the partition

#### Signature

```python
 lead(self: duckdb.duckdb.DuckDBPyRelation, column: str, window_spec: str, offset: int = 1, default_value: str = 'NULL', ignore_nulls: bool = False, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.lead()
```


##### Result

```text

```

----

### list

#### Description

Returns a list containing all values present in a given column

#### Signature

```python
 list(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.list()
```


##### Result

```text

```

----

### max

#### Description

Returns the maximum value present in a given column

#### Signature

```python
 max(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.max()
```


##### Result

```text

```

----

### mean

#### Description

Computes the average on a given column

#### Signature

```python
 mean(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.mean()
```


##### Result

```text

```

----

### median

#### Description

Computes the median over all values present in a given column

#### Signature

```python
 median(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.median()
```


##### Result

```text

```

----

### min

#### Description

Returns the minimum value present in a given column

#### Signature

```python
 min(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.min()
```


##### Result

```text

```

----

### mode

#### Description

Computes the mode over all values present in a given column

#### Signature

```python
 mode(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.mode()
```


##### Result

```text

```

----

### n_tile

#### Description

Divides the partition as equally as possible into num_buckets

#### Signature

```python
 n_tile(self: duckdb.duckdb.DuckDBPyRelation, window_spec: str, num_buckets: int, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.n_tile()
```


##### Result

```text

```

----

### nth_value

#### Description

Computes the nth value within the partition

#### Signature

```python
 nth_value(self: duckdb.duckdb.DuckDBPyRelation, column: str, window_spec: str, offset: int, ignore_nulls: bool = False, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.nth_value()
```


##### Result

```text

```

----

### percent_rank

#### Description

Computes the relative rank within the partition

#### Signature

```python
 percent_rank(self: duckdb.duckdb.DuckDBPyRelation, window_spec: str, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.percent_rank()
```


##### Result

```text

```

----

### product

#### Description

Returns the product of all values present in a given column

#### Signature

```python
 product(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.product()
```


##### Result

```text

```

----

### quantile

#### Description

Computes the exact quantile value for a given column

#### Signature

```python
 quantile(self: duckdb.duckdb.DuckDBPyRelation, column: str, q: object = 0.5, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.quantile()
```


##### Result

```text

```

----

### quantile_cont

#### Description

Computes the interpolated quantile value for a given column

#### Signature

```python
 quantile_cont(self: duckdb.duckdb.DuckDBPyRelation, column: str, q: object = 0.5, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.quantile_cont()
```


##### Result

```text

```

----

### quantile_disc

#### Description

Computes the exact quantile value for a given column

#### Signature

```python
 quantile_disc(self: duckdb.duckdb.DuckDBPyRelation, column: str, q: object = 0.5, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.quantile_disc()
```


##### Result

```text

```

----

### rank

#### Description

Computes the rank within the partition

#### Signature

```python
 rank(self: duckdb.duckdb.DuckDBPyRelation, window_spec: str, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.rank()
```


##### Result

```text

```

----

### rank_dense

#### Description

Computes the dense rank within the partition

#### Signature

```python
 rank_dense(self: duckdb.duckdb.DuckDBPyRelation, window_spec: str, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.rank_dense()
```


##### Result

```text

```

----

### row_number

#### Description

Computes the row number within the partition

#### Signature

```python
 row_number(self: duckdb.duckdb.DuckDBPyRelation, window_spec: str, projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.row_number()
```


##### Result

```text

```

----

### select_dtypes

#### Description

Select columns from the relation, by filtering based on type(s)

#### Signature

```python
 select_dtypes(self: duckdb.duckdb.DuckDBPyRelation, types: object) -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.select_dtypes()
```


##### Result

```text

```

----

### select_types

#### Description

Select columns from the relation, by filtering based on type(s)

#### Signature

```python
 select_types(self: duckdb.duckdb.DuckDBPyRelation, types: object) -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.select_types()
```


##### Result

```text

```

----

### std

#### Description

Computes the sample standard deviation for a given column

#### Signature

```python
 std(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.std()
```


##### Result

```text

```

----

### stddev

#### Description

Computes the sample standard deviation for a given column

#### Signature

```python
 stddev(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.stddev()
```


##### Result

```text

```

----

### stddev_pop

#### Description

Computes the population standard deviation for a given column

#### Signature

```python
 stddev_pop(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.stddev_pop()
```


##### Result

```text

```

----

### stddev_samp

#### Description

Computes the sample standard deviation for a given column

#### Signature

```python
 stddev_samp(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.stddev_samp()
```


##### Result

```text

```

----

### string_agg

#### Description

Concatenates the values present in a given column with a separator

#### Signature

```python
 string_agg(self: duckdb.duckdb.DuckDBPyRelation, column: str, sep: str = ',', groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.string_agg()
```


##### Result

```text

```

----

### sum

#### Description

Computes the sum of all values present in a given column

#### Signature

```python
 sum(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.sum()
```


##### Result

```text

```

----

### unique

#### Description

Returns the distinct values in a column.

#### Signature

```python
 unique(self: duckdb.duckdb.DuckDBPyRelation, unique_aggr: str) -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.unique()
```


##### Result

```text

```

----

### value_counts

#### Description

Computes the number of elements present in a given column, also projecting the original column

#### Signature

```python
 value_counts(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.value_counts()
```


##### Result

```text

```

----

### var

#### Description

Computes the sample variance for a given column

#### Signature

```python
 var(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.var()
```


##### Result

```text

```

----

### var_pop

#### Description

Computes the population variance for a given column

#### Signature

```python
 var_pop(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.var_pop()
```


##### Result

```text

```

----

### var_samp

#### Description

Computes the sample variance for a given column

#### Signature

```python
 var_samp(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.var_samp()
```


##### Result

```text

```

----

### variance

#### Description

Computes the sample variance for a given column

#### Signature

```python
 variance(self: duckdb.duckdb.DuckDBPyRelation, column: str, groups: str = '', window_spec: str = '', projected_columns: str = '') -> duckdb.duckdb.DuckDBPyRelation
```

##### Example

```python
import duckdb

duckdb_conn = duckdb.connect()

duckdb_conn.sql("drop table if exists code_example")

duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
).to_table("code_example")

rel = duckdb_conn.table("code_example")

rel.variance()
```


##### Result

```text

```

## Output 

This section contains the functions which will trigger an SQL execution and retrieve the data.

### arrow

#### Description

Execute and fetch all rows as an Arrow Table

#### Signature

```python
 arrow(self: duckdb.duckdb.DuckDBPyRelation, batch_size: int = 1000000) -> pyarrow.lib.Table
```

----

### close

#### Description

Closes the result

#### Signature

```python
 close(self: duckdb.duckdb.DuckDBPyRelation) -> None
```

----

### create

#### Description

Creates a new table named table_name with the contents of the relation object

#### Signature

```python
 create(self: duckdb.duckdb.DuckDBPyRelation, table_name: str) -> None
```

----

### create_view

#### Description

Creates a view named view_name that refers to the relation object

#### Signature

```python
 create_view(self: duckdb.duckdb.DuckDBPyRelation, view_name: str, replace: bool = True) -> duckdb.duckdb.DuckDBPyRelation
```

----

### df

#### Description

Execute and fetch all rows as a pandas DataFrame

#### Signature

```python
 df(self: duckdb.duckdb.DuckDBPyRelation, *, date_as_object: bool = False) -> pandas.DataFrame
```

----

### execute

#### Description

Transform the relation into a result set

#### Signature

```python
 execute(self: duckdb.duckdb.DuckDBPyRelation) -> duckdb.duckdb.DuckDBPyRelation
```

----

### fetch_arrow_reader

#### Description

Execute and return an Arrow Record Batch Reader that yields all rows

#### Signature

```python
 fetch_arrow_reader(self: duckdb.duckdb.DuckDBPyRelation, batch_size: int = 1000000) -> pyarrow.lib.RecordBatchReader
```

----

### fetch_arrow_table

#### Description

Execute and fetch all rows as an Arrow Table

#### Signature

```python
 fetch_arrow_table(self: duckdb.duckdb.DuckDBPyRelation, batch_size: int = 1000000) -> pyarrow.lib.Table
```

----

### fetch_df_chunk

#### Description

Execute and fetch a chunk of the rows

#### Signature

```python
 fetch_df_chunk(self: duckdb.duckdb.DuckDBPyRelation, vectors_per_chunk: int = 1, *, date_as_object: bool = False) -> pandas.DataFrame
```

----

### fetchall

#### Description

Execute and fetch all rows as a list of tuples

#### Signature

```python
 fetchall(self: duckdb.duckdb.DuckDBPyRelation) -> list
```

----

### fetchdf

#### Description

Execute and fetch all rows as a pandas DataFrame

#### Signature

```python
 fetchdf(self: duckdb.duckdb.DuckDBPyRelation, *, date_as_object: bool = False) -> pandas.DataFrame
```

----

### fetchmany

#### Description

Execute and fetch the next set of rows as a list of tuples

#### Signature

```python
 fetchmany(self: duckdb.duckdb.DuckDBPyRelation, size: int = 1) -> list
```

----

### fetchnumpy

#### Description

Execute and fetch all rows as a Python dict mapping each column to one numpy arrays

#### Signature

```python
 fetchnumpy(self: duckdb.duckdb.DuckDBPyRelation) -> dict
```

----

### fetchone

#### Description

Execute and fetch a single row as a tuple

#### Signature

```python
 fetchone(self: duckdb.duckdb.DuckDBPyRelation) -> typing.Optional[tuple]
```

----

### pl

#### Description

Execute and fetch all rows as a Polars DataFrame

#### Signature

```python
 pl(self: duckdb.duckdb.DuckDBPyRelation, batch_size: int = 1000000) -> duckdb::PolarsDataFrame
```

----

### record_batch

#### Description

Execute and return an Arrow Record Batch Reader that yields all rows

#### Signature

```python
 record_batch(self: duckdb.duckdb.DuckDBPyRelation, batch_size: int = 1000000) -> pyarrow.lib.RecordBatchReader
```

----

### tf

#### Description

Fetch a result as dict of TensorFlow Tensors

#### Signature

```python
 tf(self: duckdb.duckdb.DuckDBPyRelation) -> dict
```

----

### to_arrow_table

#### Description

Execute and fetch all rows as an Arrow Table

#### Signature

```python
 to_arrow_table(self: duckdb.duckdb.DuckDBPyRelation, batch_size: int = 1000000) -> pyarrow.lib.Table
```

----

### to_csv

#### Description

Write the relation object to a CSV file in 'file_name'

#### Signature

```python
 to_csv(self: duckdb.duckdb.DuckDBPyRelation, file_name: str, *, sep: object = None, na_rep: object = None, header: object = None, quotechar: object = None, escapechar: object = None, date_format: object = None, timestamp_format: object = None, quoting: object = None, encoding: object = None, compression: object = None, overwrite: object = None, per_thread_output: object = None, use_tmp_file: object = None, partition_by: object = None, write_partition_columns: object = None) -> None
```

----

### to_df

#### Description

Execute and fetch all rows as a pandas DataFrame

#### Signature

```python
 to_df(self: duckdb.duckdb.DuckDBPyRelation, *, date_as_object: bool = False) -> pandas.DataFrame
```

----

### to_parquet

#### Description

Write the relation object to a Parquet file in 'file_name'

#### Signature

```python
 to_parquet(self: duckdb.duckdb.DuckDBPyRelation, file_name: str, *, compression: object = None, field_ids: object = None, row_group_size_bytes: object = None, row_group_size: object = None, overwrite: object = None, per_thread_output: object = None, use_tmp_file: object = None, partition_by: object = None, write_partition_columns: object = None, append: object = None) -> None
```

----

### to_table

#### Description

Creates a new table named table_name with the contents of the relation object

#### Signature

```python
 to_table(self: duckdb.duckdb.DuckDBPyRelation, table_name: str) -> None
```

----

### to_view

#### Description

Creates a view named view_name that refers to the relation object

#### Signature

```python
 to_view(self: duckdb.duckdb.DuckDBPyRelation, view_name: str, replace: bool = True) -> duckdb.duckdb.DuckDBPyRelation
```

----

### torch

#### Description

Fetch a result as dict of PyTorch Tensors

#### Signature

```python
 torch(self: duckdb.duckdb.DuckDBPyRelation) -> dict
```

----

### write_csv

#### Description

Write the relation object to a CSV file in 'file_name'

#### Signature

```python
 write_csv(self: duckdb.duckdb.DuckDBPyRelation, file_name: str, *, sep: object = None, na_rep: object = None, header: object = None, quotechar: object = None, escapechar: object = None, date_format: object = None, timestamp_format: object = None, quoting: object = None, encoding: object = None, compression: object = None, overwrite: object = None, per_thread_output: object = None, use_tmp_file: object = None, partition_by: object = None, write_partition_columns: object = None) -> None
```

----

### write_parquet

#### Description

Write the relation object to a Parquet file in 'file_name'

#### Signature

```python
 write_parquet(self: duckdb.duckdb.DuckDBPyRelation, file_name: str, *, compression: object = None, field_ids: object = None, row_group_size_bytes: object = None, row_group_size: object = None, overwrite: object = None, per_thread_output: object = None, use_tmp_file: object = None, partition_by: object = None, write_partition_columns: object = None, append: object = None) -> None
```
