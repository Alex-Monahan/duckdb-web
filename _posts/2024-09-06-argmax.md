---
layout: post
title: "Fast Top N Aggregation and Filtering with DuckDB"
author: "Alex Monahan"
excerpt: "Find the top N values or filter to the latest N rows more quickly and easily with the `N` parameter in the `min`, `max`, `min_by`, and `max_by` aggregate functions."
---

<!-- Databases that support argmax / max_by: Snowflake, Databricks, Bigquery, StarRocks Clickhouse, Postgres (extension), Vertica,  -->
<!-- 
    What does it mean to retrieve the top N?
        Limit is the top N for the whole dataset
        This comes into play when you want the top N by group

    Use cases of top N

    Top N max vs. top N max_by
        Do you want to sort by the same thing that you want to retrieve?
        Top N with min and max works well to sort by a column and retrieve the top N values of that column.
        min_by and max_by allow you to sort by a column and then retrieve the top N of a different column (or even the entire row of data). 
            Ex: Order by total revenue descending and retrieve the top 3 customer ids by revenue.

    Use cases for max_by
        Latest event of some kind
        Top N within a group ordered by something else
    Advanced usage
        Top N
        Entire struct / unnest
    Example of the old way and the new way
        Include benchmarks
    Why is it faster? / architecture
    Example that is large enough to force spilling to disk (or lower the memory limit to make a point)
        If I lower the memory limit I can measure how low it can go, as well as compare performance
    
    Conclusion

 -->

## Introduction to Top N by Group

A common pattern when analyzing data is to look for the rows of data that are the highest or lowest in a particular metric.
When interested in the highest or lowest `N` rows in an entire dataset, SQL's standard `ORDER BY` and `LIMIT` clauses will sort by the metric of interest and only return `N` rows.
For example:

<!-- TODO: Add in the truncated results for these queries -->

```sql
-- Generate an example TPCH dataset
call dbgen(sf=1);

-- Return the most recent 3 rows by l_shipdate
FROM lineitem 
ORDER BY 
    l_shipdate DESC 
LIMIT 3;
```

| l_orderkey | l_partkey | ... | l_shipmode |              l_comment              |
|-----------:|----------:|-----|------------|-------------------------------------|
| 354528     | 6116      | ... | MAIL       | wake according to the u             |
| 413956     | 16402     | ... | SHIP       | usual patterns. carefull            |
| 484581     | 10970     | ... | TRUCK      | ccounts maintain. dogged accounts a |

This is useful to quickly get the oldest or newest values in a dataset or to find outliers in a particular metric.

Another common approach is to query the min/max summary statistics of one or more columns. 
This can find outliers, but the row that contains the outlier can be different for each column, so it is answering a different question.
DuckDB's helpful `COLUMNS` expression allows us to calculate the maximum value for all columns.

```sql
FROM lineitem
SELECT 
    MAX(COLUMNS(*));
```

| l_orderkey | l_partkey | ... | l_shipmode |  l_comment  |
|-----------:|----------:|-----|------------|-------------|
| 600000     | 20000     | ... | TRUCK      | zzle. slyly |

However, these two approaches can only answer certain kinds of questions. 
There are many scenarios where the goal is to understand the top N values *within a group*.
In the first example above, how would we calculate the last 10 shipments from each supplier?
SQL's `LIMIT` clause is not able to handle that situation. 
Let's call this type of analysis the top N by group. 

This type of analysis is a common tool for exploring new datasets. 
Use cases include pulling the most recent few rows for each group or finding the most extreme few values in a group.
Sticking with our shipment example, we could look at the last 10 shipments of each part number, or find the 5 highest priced orders per customer. 

## Traditional Top N by Group

In most databases, the way to filter to the top N within a group is to use a window function and a Common Table Expression (CTE). 
This approach also works in DuckDB.
This example returns the 3 most recent shipments for each supplier:

```sql
WITH ranked_lineitem as (
    FROM lineitem 
    SELECT 
        *,
        row_number() OVER (PARTITION BY l_suppkey ORDER BY l_shipdate DESC) as my_ranking
)
FROM ranked_lineitem
WHERE 
    my_ranking <= 3;
```

| l_orderkey | l_partkey | l_suppkey | ... | l_shipmode |                 l_comment                 | my_ranking |
|-----------:|----------:|----------:|-----|------------|-------------------------------------------|-----------:|
| 1310688    | 169532    | 7081      | ... | RAIL       | ully final exc                            | 1          |
| 910561     | 194561    | 7081      | ... | SHIP       | ly bold excuses caj                       | 2          |
| 4406883    | 179529    | 7081      | ... | RAIL       | tions. furious                            | 3          |
| 4792742    | 52095     | 7106      | ... | RAIL       | onic, ironic courts. final deposits sleep | 1          |
| 4010212    | 122081    | 7106      | ... | MAIL       |  accounts cajole finally ironic instruc   | 2          |
| 1220871    | 94596     | 7106      | ... | TRUCK      | regular requests above t                  | 3          |
| ...   | ...   | ...   | ...   | ...   | ...   | ...   |

In DuckDB, this can be simplified using the `QUALIFY` clause.
`QUALIFY` acts like a `WHERE` clause, but specifically operates on the results of window functions. 
By making this adjustment, the CTE can be avoided.

```sql
FROM lineitem 
SELECT 
    *,
    row_number() OVER (PARTITION BY l_suppkey ORDER BY l_shipdate DESC) as my_ranking
QUALIFY
    my_ranking <= 3;
```

This is certainly a viable approach!
However, what are its weaknesses? 
Even though the query is interested in only the 3 most recent shipments, it must sort every shipment just to retrieve those top 3.
Sorting in DuckDB has a complexity of `O(kn)` due to DuckDB's innovative [Radix sort implementation]({% post_url 2021-08-27-external-sorting %}), but this is still higher than the `O(n)` of [DuckDB's hash aggregate]({% post_url 2024-03-29-external-aggregation %}), for example.
Sorting is also a memory intensive operation when compared with aggregation. 


## Top N in DuckDB

DuckDB 1.1 added a new capability to dramatically simplify and improve performance of top N calculations.
The functions `min`, `max`, `min_by`, and `max_by` all now accept an optional parameter `N`.
If `N` is greater than 1 (the default), they will return an array of the top values.

As a simple example, let's query the most recent (top 3) shipment dates:

```sql
FROM lineitem
SELECT 
    MAX(l_shipdate, 3) as top_3_shipdates;
```

|           top_3_shipdates            |
|--------------------------------------|
| [1998-12-01, 1998-12-01, 1998-12-01] |

## Top N by Column in DuckDB

This can become even more useful thanks to the `COLUMNS` expression once again - we can retrieve the 3 top values in each column. 
We can call this a top N by column analysis. 
It is particularly messy to try to do this analysis with ordinary SQL!
You would need a subquery or window function for every single column...
In DuckDB, simply:

```sql
FROM lineitem
SELECT 
    MAX(COLUMNS(*), 3) as "top_3_\0";
```

|     top_3_l_orderkey     |    top_3_l_partkey    | ... |   top_3_l_shipmode    |                               top_3_l_comment                                |
|--------------------------|-----------------------|-----|-----------------------|------------------------------------------------------------------------------|
| [600000, 600000, 599975] | [20000, 20000, 20000] | ... | [TRUCK, TRUCK, TRUCK] | [zzle. slyly, zzle. quickly bold a, zzle. pinto beans boost slyly slyly fin] |

## Top N by Group in DuckDB

Armed with the new `N` parameter, how can we simplify a top N by group analysis?


## Top N by Column



## Top N by Column in DuckDB

 <!-- 


 
  -->