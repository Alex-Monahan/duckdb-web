#!/usr/bin/env python3

import duckdb

DOC_CATEGORY_MAP = {
    'docs/stable/sql/functions/blob.md': 'blob',
    'docs/stable/sql/functions/char.md': 'string',
}

# 'functions' that are binary operators are listed between the arguments
BINARY_OPERATORS = ['||', '^@', 'LIKE', 'SIMILAR TO']
EXTRACT_OPERATOR = '[]'

# override/add to duckdb_functions() outputs:
# - key: tuple: (category, function_name)
# - value: LIST[tuple: (parameters, description, examples, aliases)]
OVERRIDES_MAP = {
    ('blob', '||'): [
        (
            ['blob', 'blob'],
            '`BLOB` concatenation.',
            [r"'\xAA'::BLOB || '\xBB'::BLOB"],
            [],
        )
    ],
    ('blob', 'read_blob'): [
        (
            ['source'],
            'Returns the content from `source` (a filename, a list of filenames, or a glob pattern) as a `BLOB`. See the `read_blob` guide for more details.',
            ["read_blob('hello.bin')"],
            [],
        )
    ],
    ('string', '||'): [
        (
            ['string', 'string'],
            'Concatenates two strings. Any `NULL` input results in `NULL`. See also `concat(string, ...)`.',
            ["'Duck' || 'DB'"],
            [],
        )
    ],
    ('string', '[]'): [
        (
            ['string', 'index'],
            'Extracts a single character using a (1-based) index.',
            ["'DuckDB'[4]"],
            ['array_extract'],
        ),
        (
            ['string', 'begin', 'end'],
            'Extracts a string using slice conventions similar to Python. Missing `begin` or `end` arguments are interpreted as the beginning or end of the list respectively. Negative values are accepted.',
            ["'DuckDB'[:4]"],
            ['array_slice'],
        ),
    ],
    ('string', 'LIKE'): [
        (
            ['string', 'target'],
            'Returns `true` if the `string` matches the like specifier (see Pattern Matching).',
            ["'hello' LIKE '%lo'"],
            [],
        )
    ],
    ('string', 'SIMILAR TO'): [
        (
            ['string', 'regex'],
            'Returns `true` if the `string` matches the `regex` (see Pattern Matching).',
            ["'hello' SIMILAR TO 'l+'"],
            ['regexp_full_match'],
        )
    ],
}

URL_CONVERSIONS = {
    '`read_blob` guide': ('docs/stable/guides/file_formats/read_file.md', '#read_blob'),
    '`concat(string, ...)`': ('', "#concatstring-"),
}

# for these functions, we don't run the examples
FIXED_EXAMPLES = {('blob', 'read_blob'): r"hello\x0A"}


def main():
    for doc_file, category in DOC_CATEGORY_MAP.items():
        print(f"creating file {doc_file} ...")
        generate_doc_file(doc_file, category)


def generate_doc_file(doc_file: str, category: str) -> None:
    function_data: list[tuple[str, list[str], str, list[str], list[str]]] = (
        get_function_data(category)
    )
    startline = (
        "<!-- Start of section generated by scripts/generate_sql_function_docs.py -->\n"
    )
    endline = (
        "<!-- End of section generated by scripts/generate_sql_function_docs.py -->\n"
    )
    with open(doc_file, "r") as f:
        doc_text = f.read()
    if startline not in doc_text or endline not in doc_text:
        print(
            f"doc generation failed, start or end line is missing in file " + doc_file
        )
        exit(1)
    else:
        split_start = doc_text.rsplit(startline, 1)
        split_end = doc_text.rsplit(endline, 1)
        doc_text_new = (
            split_start[0]
            + startline
            + generate_docs_table(function_data)
            + generate_docs_records(function_data, category)
            + endline
            + split_end[1]
        )
        with open(doc_file, "w+") as f:
            f.write(doc_text_new)


def get_function_data(
    category: str,
) -> list[tuple[str, list[str], str, list[str], list[str]]]:
    query = f"""
select distinct
  f1.function_name,
  f1.parameters,
  f1.description,
  f1.examples,
  list_sort(list_distinct(list(f2.function_name))) as aliases
from
  duckdb_functions() f1
  left join duckdb_functions() f2 on (
    f1.alias_of = f2.function_name
    or f1.function_name = f2.alias_of
    or (f1.alias_of = f2.alias_of and f1.function_name != f2.function_name)
  )
where
  list_contains(f1.categories, '{category}')
group by all
order by all
"""
    function_data: list[tuple[str, list[str], str, list[str], list[str]]] = duckdb.sql(
        query
    ).fetchall()

    # apply overrides and add additional functions
    function_data = [
        func for func in function_data if (category, func[0]) not in OVERRIDES_MAP
    ]
    for k, v in OVERRIDES_MAP.items():
        override_category, function_name = k
        if override_category == category:
            for override in v:
                function_data.append((function_name, *override))

    # sort on: function_name, nr of arguments, argument names
    sorter = lambda func: f"{func[0]}-{len(func[1])}-{func[1]}"
    function_data_1 = sorted(
        [func for func in function_data if func[0] == EXTRACT_OPERATOR], key=sorter
    )
    function_data_2 = sorted(
        [func for func in function_data if func[0] in BINARY_OPERATORS], key=sorter
    )
    function_data_3 = sorted(
        [
            func
            for func in function_data
            if (func[0] not in BINARY_OPERATORS) and (func[0] != EXTRACT_OPERATOR)
        ],
        key=sorter,
    )
    function_data = function_data_1 + function_data_2 + function_data_3

    # apply url conversions
    for conversion in URL_CONVERSIONS:
        for idx, function in enumerate(function_data):
            if conversion in function[2]:
                url_desc = function[2].replace(
                    conversion,
                    f"[{conversion}]"
                    "({% "
                    f"link {URL_CONVERSIONS[conversion][0]}"
                    " %}"
                    f"{URL_CONVERSIONS[conversion][1]})",
                )
                function_name, parameters, _, examples, aliases = function_data[idx]
                function_data[idx] = (
                    function_name,
                    parameters,
                    url_desc,
                    examples,
                    aliases,
                )
    return function_data


def generate_docs_table(
    function_data: list[tuple[str, list[str], str, list[str], list[str]]]
):
    res = "<!-- markdownlint-disable MD056 -->\n\n"
    res += "| Name | Description |\n|:--|:-------|\n"
    for func in function_data:
        function_name, params, description, examples, _ = func
        if not examples:
            print(f"WARNING (skipping): '{function_name}' - no example is available")
            continue
        if function_name in BINARY_OPERATORS and len(params) == 2:
            res += f"| [`{params[0]} {function_name} {params[1]}`](#{params[0]}--{params[1]}) | {description} |\n"
        elif function_name == EXTRACT_OPERATOR and len(params) >= 2:
            res += f"| [`{params[0]}[{":".join(params[1:])}]`](#{"".join(params)}) | {description} |\n"
        else:
            res += f"| [`{function_name}({", ".join(params)})`](#{function_name.lstrip('@*!^')}{"-".join(params)}) | {description} |\n"
    res += "\n<!-- markdownlint-enable MD056 -->\n"
    return res


def generate_docs_records(
    function_data: list[tuple[str, list[str], str, list[str], list[str]]], category: str
):
    res = "\n"
    for func in function_data:
        function_name, params, description, examples, aliases = func
        if not examples:
            print(f"skipping {function_name}")
            continue
        if len(examples) > 1:
            print(f"WARNING: '{function_name}' multiple examples available: {examples}")
        example = examples[0]
        if function_name in BINARY_OPERATORS and len(params) == 2:
            res += f"#### `{params[0]} {function_name} {params[1]}`\n\n"
        elif function_name == EXTRACT_OPERATOR and len(params) >= 2:
            res += f"#### `{params[0]}[{":".join(params)}]`\n\n"
        else:
            res += f"#### `{function_name}({", ".join(params)})`\n\n"
        res += '<div class="nostroke_table"></div>\n\n'
        res += f"| **Description** | {description} |\n"
        res += f"| **Example** | `{example}` |\n"
        if (category, function_name) in FIXED_EXAMPLES:
            res += f"| **Result** | `{FIXED_EXAMPLES[(category, function_name)]}` |\n"
        else:
            example_result = ""
            try:
                example_result = duckdb.sql(rf"select {example}::VARCHAR").fetchone()[0]
            except duckdb.ParserException as e:
                print(
                    f"Error for function '{function_name}', could not calculate example: '{example}'. Consider adding it to 'FIXED_EXAMPLES'. {e}"
                )
            res += f"| **Result** | `{example_result}` |\n"
        if aliases:
            res += f"| **Alias** | {','.join(f"`{alias}`" for alias in aliases)} |\n"
        res += '\n'
    return res


if __name__ == "__main__":
    main()
