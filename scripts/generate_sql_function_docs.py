#!/usr/bin/env python3

import duckdb

DOC_CATEGORY_MAP = {'docs/sql/functions/blob.md': 'blob'}

# 'functions' that are binary operators are listed between the arguments
BINARY_OPERATORS = ['||']

# override/add to duckdb_functions() outputs:
# - key: tuple: (category, function_name)
# - value: tuple: (parameters, description, examples)
OVERRIDES_MAP = {
    ('blob', '||'): (['blob', 'blob'], '`BLOB` concatenation.', [r"'\xAA'::BLOB || '\xBB'::BLOB"]),
    ('blob', 'read_blob'): (
        ['source'],
        'Returns the content from `source` (a filename, a list of filenames, or a glob pattern) as a `BLOB`. See the `read_blob` guide for more details.',
        ["read_blob('hello.bin')"],
    ),
}

URL_CONVERSIONS = {
    '`read_blob` guide': ('docs/guides/file_formats/read_file.md', '#read_blob')
}

# for these functions, we don't run the examples
FIXED_EXAMPLES = {
    ('blob', 'read_blob'): r"hello\x0A"
}


def main():
    for doc_file, category in DOC_CATEGORY_MAP.items():
        generate_doc_file(doc_file, category)


def generate_doc_file(doc_file: str, category: str) -> None:
    function_data: list[tuple[str, list[str], str, list[str]]] = get_function_data(category)
    startline = "<!-- Start of section generated by scripts/generate_sql_function_docs.py -->\n"
    endline = "<!-- End of section generated by scripts/generate_sql_function_docs.py -->\n"
    with open(doc_file, "r") as f:
        doc_text = f.read()
    if startline not in doc_text or endline not in doc_text:
        print(f"doc generation failed, start or end line is missing in file " + doc_file)
        exit(1)
    else:
        split_start = doc_text.rsplit(startline, 1)
        split_end = doc_text.rsplit(endline, 1)
        doc_text_new = (
            split_start[0]
            + startline
            + generate_docs_table(function_data)
            + generate_docs_records(function_data, category)
            + endline
            + split_end[1]
        )
        with open(doc_file, "w+") as f:
            f.write(doc_text_new)


def get_function_data(category: str) -> list[tuple[str, list[str], str, list[str]]]:
    query = f"""
select
    function_name,
    parameters,
    description,
    examples,
from
    duckdb_functions()
where
    list_contains(categories, '{category}')
order by
    function_name
;
"""
    function_data: list[tuple[str, list[str], str, list[str]]] = duckdb.sql(query).fetchall()

    # apply overrides and add additional functions
    all_function_dict = {func[0]: idx for idx, func in enumerate(function_data)}
    for override_category, function_name in OVERRIDES_MAP:
        if override_category == category:
            params, description, examples = OVERRIDES_MAP[(category, function_name)]
            if function_name in all_function_dict:
                function_data[all_function_dict[function_name]] = (function_name, params, description, examples)
            else:
                function_data.append((function_name, params, description, examples))
    function_data.sort()

    # rotate non-alphanumeric functions (i.e. operators) from bottom to top
    # (bit crude, because i don't want to add pip install icu dependency)
    idx = len(function_data) - 1
    operator_count = 0
    while idx >= 0:
        if not function_data[idx][0][0].isalnum():
            operator_count += 1
        else:
            break
        idx -= 1
    function_data = function_data[-1 * operator_count :] + function_data[: -1 * operator_count]

    # apply url conversions
    for conversion in URL_CONVERSIONS:
        for idx, function in enumerate(function_data):
            if conversion in function[2]:
                url_desc = function[2].replace(
                    conversion,
                    f"[{conversion}]"
                    "({% " f"link {URL_CONVERSIONS[conversion][0]}" " %}"
                    f"{URL_CONVERSIONS[conversion][1]})",
                )
                function_name, parameters, _, examples = function_data[idx]
                function_data[idx] = (function_name, parameters, url_desc, examples)
    return function_data


def generate_docs_table(function_data: list[tuple[str, list[str], str, list[str]]]):
    res = "<!-- markdownlint-disable MD056 -->\n\n"
    res += "| Name | Description |\n|:--|:-------|\n"
    for func in function_data:
        function_name, params, description, _ = func
        if function_name in BINARY_OPERATORS and len(params) == 2:
            res += f"| [`{params[0]} {function_name} {params[1]}`](#{params[0]}--{params[1]}) | {description} |\n"
        else:
            res += f"| [`{function_name}({", ".join(params)})`](#{function_name.lstrip('@*!^')}{"-".join(params)}) | {description} |\n"
    res += "\n<!-- markdownlint-enable MD056 -->\n"
    return res


def generate_docs_records(function_data: list[tuple[str, list[str], str, list[str]]], category: str):
    res = "\n"
    for func in function_data:
        function_name, params, description, examples = func
        if function_name in BINARY_OPERATORS and len(params) == 2:
            res += f"#### `{params[0]} {function_name} {params[1]}`\n\n"
        else:
            res += f"#### `{function_name}({", ".join(params)})`\n\n"
        res += '<div class="nostroke_table"></div>\n\n'
        res += f"| **Description** | {description} |\n"
        res += f"| **Example** | `{examples[0]}` |\n"
        if (category, function_name) in FIXED_EXAMPLES:
            res += f"| **Result** | `{FIXED_EXAMPLES[(category, function_name)]}` |\n\n"
        else:
            res += f"| **Result** | `{duckdb.sql(rf"select {examples[0]}::VARCHAR").fetchone()[0]}` |\n\n"
    return res


if __name__ == "__main__":
    main()
