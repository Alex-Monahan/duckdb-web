import duckdb

import inspect

import warnings

from generate_python_relational_docs_examples import (
    CODE_EXAMPLE_MAP,
    DEFAULT_EXAMPLE,
    PLACEHOLDER_EXAMPLE,
    PLACEHOLDER_RESULT,
)
from generate_python_relational_docs_methods import (
    CREATION_MEMBER_LIST,
    PY_RELATION_MEMBERS,
    DEFINITION_MEMBER_LIST,
    TRANSFORMATION_MEMBER_LIST,
    FUNCTION_MEMBER_LIST,
    OUTPUT_MEMBER_LIST,
)

FORMATTER_TEXT = """---
layout: docu
redirect_from:
- /docs/api/python/relational_api
- /docs/api/python/relational_api/
- /docs/clients/python/relational_api
title: Relational API
---

<!-- Generated by scripts/generate_python_relational_docs.py -->

"""

INTRODUCTION_TEXT = """
The Relational API is an alternative API that can be used to incrementally construct queries. 
The API is centered around `DuckDBPyRelation` nodes. The relations can be seen as symbolic representations of SQL queries. 

## Lazy Evaluation
The relations do not hold any data – and nothing is executed – until [a method that triggers execution](#output) is called.

For example, we create a relation, which loads 1 billion rows:
```python
import duckdb

duckdb_conn = duckdb.connect()

rel = duckdb_conn.sql("from range(1_000_000_000)")
```
At the moment of execution, `rel` does not hold any data and no data is retrieved from the database.

By calling `rel.show()` or simply printing `rel` on the terminal, the first 10K rows are fetched.
If there are more than 10K rows, the output window will show >9999 rows (as the amount of rows in the relation is unknown).

By calling an [output](#output) method, the data is retrieved and stored in the specified format:

```python
rel.to_table("example_rel")

# 100% ▕████████████████████████████████████████████████████████████▏ 
```
"""

SECTION_MAP = {
    "Relation Creation": {
        "id": 1,
        "description": "This section contains the details on how a relation is created. \
        The methods are [lazy evaluated](#lazy-evaluation).",
        "method_list": [
            {"class": duckdb.DuckDBPyConnection, "members": CREATION_MEMBER_LIST}
        ],
    },
    "Relation Definition Details": {
        "id": 2,
        "description": "This section contains the details on how to inspect a relation.",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": DEFINITION_MEMBER_LIST}
        ],
    },
    "Transformation": {
        "id": 3,
        "description": "This section contains the methods which can be used to chain queries.\
        The methods are [lazy evaluated](#lazy-evaluation).",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": TRANSFORMATION_MEMBER_LIST}
        ],
    },
    "Functions": {
        "id": 4,
        "description": "This section contains the functions which can be applied to an relation, \
        in order to get a (scalar) result. The functions are [lazy evaluated](#lazy-evaluation).",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": FUNCTION_MEMBER_LIST}
        ],
    },
    "Output": {
        "id": 5,
        "description": "This section contains the functions which will trigger an SQL execution and retrieve the data.",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": OUTPUT_MEMBER_LIST}
        ],
    },
}


def get_duckdb_conn():
    duckdb_conn = duckdb.connect()
    duckdb_conn.sql(
        """
        CREATE TABLE relational_api_members(
            class_name text,
            member_name text,
            section text,
            section_id integer,
            member_signature text,
            member_description text,
            member_toc_line text,
            member_example text,
            member_result text,
            primary key (class_name, member_name)
        )
    """
    )
    return duckdb_conn


def populate_member_details(relational_api_table, class_name, member_list, section):
    """

    :param relational_api_table: the table to store docs info
    :param class_name: the class to be inspected
    :param member_list: the list of methods to be inspected
    :param section: the section from the md file
    :return:
        For each method the doc is parsed into signature and description
        and the examples are rendered under md code
    """

    for class_member in inspect.getmembers(class_name):
        class_member_name = class_member[0]
        class_member_value = class_member[1]
        member_anchor = class_member_name
        member_signature = None
        member_description = None

        if class_member_name not in member_list:
            continue

        if inspect.getdoc(class_member_value):
            member_docs = inspect.getdoc(class_member_value).split("\n\n")
            if len(member_docs) >= 2:
                member_signature = member_docs[0]
                member_description = '\n'.join(member_docs[1:])
            else:
                member_description = member_docs[0]

            if class_member_name in ['from_parquet', 'read_parquet']:
                member_description = "Create a relation object from the Parquet files"
            number_of_duplicates = (
                relational_api_table.filter(f"member_name = '{class_member_name}'")
                .count("member_name")
                .fetchone()
            )[0]
            if number_of_duplicates > 0:
                member_anchor = f"{class_member_name}-{number_of_duplicates}"

        relational_api_table.insert(
            [
                class_name.__name__,
                class_member_name,
                section,
                SECTION_MAP.get(section).get("id"),
                f"```python\n {member_signature}\n```" if member_signature else None,
                f"{member_description}{CODE_EXAMPLE_MAP.get(member_anchor).get('additional_description', '') if CODE_EXAMPLE_MAP.get(member_anchor) else ''}",
                f"| [`{class_member_name}`](#{member_anchor}) | {member_description} |",
                (
                    DEFAULT_EXAMPLE.format(
                        code_example=CODE_EXAMPLE_MAP.get(member_anchor).get("example")
                    )
                    if CODE_EXAMPLE_MAP.get(member_anchor)
                    and CODE_EXAMPLE_MAP.get(member_anchor).get("default", True)
                    else (
                        PLACEHOLDER_EXAMPLE.format(
                            code_example=CODE_EXAMPLE_MAP.get(member_anchor).get(
                                "example"
                            )
                        )
                        if CODE_EXAMPLE_MAP.get(member_anchor)
                        else None
                    )
                ),
                (
                    PLACEHOLDER_RESULT.format(
                        result=CODE_EXAMPLE_MAP.get(member_anchor).get("result"),
                        result_type=CODE_EXAMPLE_MAP.get(member_anchor).get(
                            "result_type", "text"
                        ),
                    ).replace("\n\n", "\n")
                    if CODE_EXAMPLE_MAP.get(member_anchor)
                    else None
                ),
            ]
        )


def generate_from_db(relational_api_table):
    with open("docs/preview/clients/python/relational_api.md", "w") as f:
        f.write(FORMATTER_TEXT)
        f.write("\n")

        f.write(INTRODUCTION_TEXT)
        f.write("\n")

        # write TOC
        toc_section = (
            relational_api_table.select('section', "section_id", 'member_toc_line')
            .string_agg(
                'member_toc_line',
                sep='\n',
                groups='section, section_id',
                projected_columns='section, section_id',
            )
            .order("section_id")
        )

        for section in toc_section.fetchall():
            f.write(
                f"\n\n**[{section[0]}](#{section[0].lower().replace(" ", "-")})**\n\n"
            )
            f.write(SECTION_MAP.get(section[0]).get("description"))
            f.write("\n\n")
            f.write("| Name | Description |\n|:--|:-------|\n")
            f.write(section[2])

        f.write("\n\n")

        # write section details
        section_details = (
            relational_api_table.select(
                """
            section,
            section_id,
            concat('### ',member_name) as header_member_name, 
            case when member_signature is not null then '\n\n#### Signature\n\n' else NULL end as header_signature, 
            member_signature,
            case when member_description is not null then '\n\n#### Description\n\n' else NULL end as header_description, 
            member_description,
            case when member_example is not null then '\n\n##### Example\n\n' else NULL end as header_example,
            member_example,
            case when member_result is not null then '\n\n##### Result\n\n' else NULL end as header_result,
            member_result
        """
            )
            .select(
                """
                section, 
                section_id, 
                concat(
                    header_member_name, 
                    header_signature, 
                    member_signature, 
                    header_description, 
                    member_description, 
                    header_example, 
                    member_example, 
                    header_result, 
                    member_result
                ) as detailed_section
            """
            )
            .string_agg(
                "detailed_section",
                sep='\n\n----\n\n',
                groups='section, section_id',
                projected_columns='section, section_id',
            )
            .order("section_id")
        )

        for section in section_details.fetchall():
            f.write(f"\n\n## {section[0]} \n\n")
            f.write(SECTION_MAP.get(section[0]).get("description"))
            f.write("\n\n")
            f.write(section[2])

        f.write("\n")


def check_fully_documented(class_name, configured_in_script, class_members):
    if too_many_doc_members := list(set(configured_in_script) - set(class_members)):
        warnings.warn(
            f"The following members are not in the {class_name} anymore: {too_many_doc_members}"
        )
    if undocumented_members := list(set(class_members) - set(configured_in_script)):
        warnings.warn(
            f"There are members which are not documented for {class_name}: {undocumented_members}"
        )


def main():
    check_fully_documented(
        class_name="DuckDBPyRelation",
        configured_in_script=PY_RELATION_MEMBERS,
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyRelation)
            if not member[0].startswith("_")
        ],
    )

    check_fully_documented(
        class_name="DuckDBPyConnection",
        configured_in_script=CREATION_MEMBER_LIST,
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyConnection)
            if inspect.getdoc(member[1])
            and '-> duckdb.duckdb.DuckDBPyRelation' in inspect.getdoc(member[1])
        ],
    )

    duckdb_conn = get_duckdb_conn()

    relational_api_table = duckdb_conn.table("relational_api_members")

    for section, section_details in SECTION_MAP.items():
        for method_list in section_details.get("method_list"):
            populate_member_details(
                relational_api_table=relational_api_table,
                class_name=method_list["class"],
                member_list=method_list["members"],
                section=section,
            )

    generate_from_db(relational_api_table)


if __name__ == "__main__":
    main()
