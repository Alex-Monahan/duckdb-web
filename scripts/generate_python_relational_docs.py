import duckdb

import inspect

import warnings

from generate_python_relational_docs_examples import (
    CREATION_MEMBER_CODE_EXAMPLE_MAP,
    DEFINITION_MEMBER_CODE_EXAMPLE_MAP,
    TRANSFORMATION_MEMBER_CODE_EXAMPLE_MAP,
    FUNCTION_MEMBER_CODE_EXAMPLE_MAP,
    OUTPUT_MEMBER_CODE_EXAMPLE_MAP,
)


FORMATTER_TEXT = """---
layout: docu
redirect_from:
- /docs/api/python/relational_api
- /docs/api/python/relational_api/
- /docs/clients/python/relational_api
title: Relational API
---

<!-- Generated by scripts/generate_python_relational_docs.py -->

"""

INTRODUCTION_TEXT = """
The Relational API is an alternative API that can be used to incrementally construct queries. 
The API is centered around `DuckDBPyRelation` nodes. The relations can be seen as symbolic representations of SQL queries. 

## Lazy Evaluation
The relations do not hold any data – and nothing is executed – until [a method that triggers execution](#output) is called.

For example, we create a relation, which loads 1 billion rows:
```python
import duckdb

duckdb_conn = duckdb.connect()

rel = duckdb_conn.sql("from range(1_000_000_000)")
```
At the moment of execution, `rel` does not hold any data and no data is retrieved from the database.

By calling `rel.show()` or simply printing `rel` on the terminal, the first 10K rows are fetched.
If there are more than 10K rows, the output window will show >9999 rows (as the amount of rows in the relation is unknown).

By calling an [output](#output) method, the data is retrieved and stored in the specified format:

```python
rel.to_table("example_rel")

# 100% ▕████████████████████████████████████████████████████████████▏ 
```
"""

DEFINITION_MEMBER_LIST = [
    "columns",
    "describe",
    "description",
    "dtypes",
    "explain",
    "query",
    "set_alias",
    "alias",
    "shape",
    "show",
    "sql_query",
    "type",
    "types",
]
TRANSFORMATION_MEMBER_LIST = [
    "aggregate",
    "apply",
    "cross",
    "except_",
    "filter",
    "insert",
    "insert_into",
    "intersect",
    "join",
    "limit",
    "map",
    "order",
    "project",
    "select",
    "sort",
    "union",
    "update",
]
FUNCTION_MEMBER_LIST = [
    "any_value",
    "arg_max",
    "arg_min",
    "avg",
    "bit_and",
    "bit_or",
    "bit_xor",
    "bitstring_agg",
    "bool_and",
    "bool_or",
    "count",
    "cume_dist",
    "dense_rank",
    "distinct",
    "favg",
    "first",
    "first_value",
    "fsum",
    "geomean",
    "histogram",
    "lag",
    "last",
    "last_value",
    "lead",
    "list",
    "max",
    "mean",
    "median",
    "min",
    "mode",
    "n_tile",
    "nth_value",
    "percent_rank",
    "product",
    "quantile",
    "quantile_cont",
    "quantile_disc",
    "rank",
    "rank_dense",
    "row_number",
    "select_dtypes",
    "select_types",
    "std",
    "stddev",
    "stddev_pop",
    "stddev_samp",
    "string_agg",
    "sum",
    "unique",
    "value_counts",
    "var",
    "var_pop",
    "var_samp",
    "variance",
]
OUTPUT_MEMBER_LIST = [
    "arrow",
    "close",
    "create",
    "create_view",
    "df",
    "execute",
    "fetch_arrow_reader",
    "fetch_arrow_table",
    "fetch_df_chunk",
    "fetchall",
    "fetchdf",
    "fetchmany",
    "fetchnumpy",
    "fetchone",
    "pl",
    "record_batch",
    "tf",
    "to_arrow_table",
    "to_csv",
    "to_df",
    "to_parquet",
    "to_table",
    "to_view",
    "torch",
    "write_csv",
    "write_parquet",
]

CREATION_MEMBER_LIST = [
    'from_arrow',
    'from_csv_auto',
    'from_df',
    'from_parquet',
    'from_query',
    'query',
    'read_csv',
    'read_json',
    'read_parquet',
    'sql',
    'table',
    'table_function',
    'values',
    'view',
]

SECTION_MAP = {
    "Relation Creation": {
        "id": 1,
        "description": "This section contains the details on how a relation is created. \
        The function methods are [lazy evaluated](#lazy-evaluation).",
    },
    "Relation Definition Details": {
        "id": 2,
        "description": "This section contains the details on how to inspect a relation.",
    },
    "Transformation": {
        "id": 3,
        "description": "This section contains the methods which can be used to chain queries.\
        The transformation methods are [lazy evaluated](#lazy-evaluation).",
    },
    "Functions": {
        "id": 4,
        "description": "This section contains the functions which can be applied to an relation, \
        in order to get a (scalar) result. The function methods are [lazy evaluated](#lazy-evaluation).",
    },
    "Output": {
        "id": 5,
        "description": "This section contains the functions which will trigger an SQL execution and retrieve the data.",
    },
}

CODE_EXAMPLE_MAP = {
    **CREATION_MEMBER_CODE_EXAMPLE_MAP,
    **DEFINITION_MEMBER_CODE_EXAMPLE_MAP,
    **TRANSFORMATION_MEMBER_CODE_EXAMPLE_MAP,
    **FUNCTION_MEMBER_CODE_EXAMPLE_MAP,
    **OUTPUT_MEMBER_CODE_EXAMPLE_MAP,
}

DEFAULT_EXAMPLE = '''```python
import duckdb

duckdb_conn = duckdb.connect()

rel = duckdb_conn.sql("""
        select 
            gen_random_uuid() as id, 
            concat('value is ', case when mod(range,2)=0 then 'even' else 'uneven' end) as description,
            range as value, 
            now() + concat(range,' ', 'minutes')::interval as created_timestamp
        from range(1, 10)
    """
)

{code_example}
```
'''

PLACEHOLDER_EXAMPLE = "```python\n{code_example}\n```"
PLACEHOLDER_RESULT = "```{result_type}\n{result}\n```"


def get_duckdb_conn():
    duckdb_conn = duckdb.connect()
    duckdb_conn.sql(
        """
        CREATE TABLE relational_api_members(
            class_name text,
            member_name text,
            section text,
            section_id integer,
            member_signature text,
            member_description text,
            member_toc_line text,
            member_example text,
            member_result text,
            primary key (class_name, member_name)
        )
    """
    )
    return duckdb_conn


def populate_member_details(relational_api_table, class_name, member_list, section):

    for class_member in inspect.getmembers(class_name):
        class_member_name = class_member[0]
        class_member_value = class_member[1]
        member_anchor = class_member_name
        member_signature = None
        member_description = None

        if class_member_name not in member_list:
            continue

        if inspect.getdoc(class_member_value):
            member_docs = inspect.getdoc(class_member_value).split("\n\n")
            if len(member_docs) >= 2:
                member_signature = member_docs[0]
                member_description = '\n'.join(member_docs[1:])
            else:
                member_description = member_docs[0]

            if class_member_name in ['from_parquet', 'read_parquet']:
                member_description = "Create a relation object from the Parquet files"
            number_of_duplicates = (
                relational_api_table.filter(f"member_name = '{class_member_name}'")
                .count("member_name")
                .fetchone()
            )[0]
            if number_of_duplicates > 0:
                member_anchor = f"{class_member_name}-{number_of_duplicates}"

        relational_api_table.insert(
            [
                class_name.__name__,
                class_member_name,
                section,
                SECTION_MAP.get(section).get("id"),
                f"```python\n {member_signature}\n```" if member_signature else None,
                member_description,
                f"| [`{class_member_name}`](#{member_anchor}) | {member_description} |",
                (
                    DEFAULT_EXAMPLE.format(
                        code_example=CODE_EXAMPLE_MAP.get(member_anchor).get("example")
                    )
                    if CODE_EXAMPLE_MAP.get(member_anchor)
                    and CODE_EXAMPLE_MAP.get(member_anchor).get("default", True)
                    else (
                        PLACEHOLDER_EXAMPLE.format(
                            code_example=CODE_EXAMPLE_MAP.get(member_anchor).get(
                                "example"
                            )
                        )
                        if CODE_EXAMPLE_MAP.get(member_anchor)
                        else None
                    )
                ),
                (
                    PLACEHOLDER_RESULT.format(
                        result=CODE_EXAMPLE_MAP.get(member_anchor).get("result"),
                        result_type=CODE_EXAMPLE_MAP.get(member_anchor).get(
                            "result_type", "text"
                        ),
                    )
                    if CODE_EXAMPLE_MAP.get(member_anchor)
                    else None
                ),
            ]
        )


def generate_from_db(relational_api_table):
    with open("docs/preview/clients/python/relational_api.md", "w") as f:
        f.write(FORMATTER_TEXT)
        f.write("\n")

        f.write(INTRODUCTION_TEXT)
        f.write("\n")

        # write TOC

        f.write("## Index")
        f.write("\n")

        toc_section = (
            relational_api_table.select('section', "section_id", 'member_toc_line')
            .string_agg(
                'member_toc_line',
                sep='\n',
                groups='section, section_id',
                projected_columns='section, section_id',
            )
            .order("section_id")
        )

        for section in toc_section.fetchall():
            f.write(
                f"\n\n**[{section[0]}](#{section[0].lower().replace(" ", "-")})**\n\n"
            )
            f.write("| Name | Description |\n|:--|:-------|\n")
            f.write(section[2])

        f.write("\n\n")

        # write section details
        section_details = (
            relational_api_table.select(
                """
            section,
            section_id,
            concat('### ',member_name) as header_member_name, 
            case when member_signature is not null then '\n\n#### Signature\n\n' else NULL end as header_signature, 
            member_signature,
            case when member_description is not null then '\n\n#### Description\n\n' else NULL end as header_description, 
            member_description,
            case when member_example is not null then '\n\n##### Example\n\n' else NULL end as header_example,
            member_example,
            case when member_result is not null then '\n\n##### Result\n\n' else NULL end as header_result,
            member_result
        """
            )
            .select(
                """
                section, 
                section_id, 
                concat(
                    header_member_name, 
                    header_signature, 
                    member_signature, 
                    header_description, 
                    member_description, 
                    header_example, 
                    member_example, 
                    header_result, 
                    member_result
                ) as detailed_section
            """
            )
            .string_agg(
                "detailed_section",
                sep='\n\n----\n\n',
                groups='section, section_id',
                projected_columns='section, section_id',
            )
            .order("section_id")
        )

        for section in section_details.fetchall():
            f.write(f"\n\n## {section[0]} \n\n")
            f.write(SECTION_MAP.get(section[0]).get("description"))
            f.write("\n\n")
            f.write(section[2])

        f.write("\n")


def check_fully_documented(class_name, configured_in_script, class_members):
    if too_many_doc_members := list(set(configured_in_script) - set(class_members)):
        warnings.warn(
            f"The following members are not in the {class_name} anymore: {too_many_doc_members}"
        )
    if undocumented_members := list(set(class_members) - set(configured_in_script)):
        warnings.warn(
            f"There are members which are not documented for {class_name}: {undocumented_members}"
        )


def main():
    check_fully_documented(
        class_name="DuckDBPyRelation",
        configured_in_script=(
            DEFINITION_MEMBER_LIST
            + TRANSFORMATION_MEMBER_LIST
            + FUNCTION_MEMBER_LIST
            + OUTPUT_MEMBER_LIST
        ),
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyRelation)
            if not member[0].startswith("_")
        ],
    )

    check_fully_documented(
        class_name="DuckDBPyConnection",
        configured_in_script=CREATION_MEMBER_LIST,
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyConnection)
            if inspect.getdoc(member[1])
            and '-> duckdb.duckdb.DuckDBPyRelation' in inspect.getdoc(member[1])
        ],
    )

    duckdb_conn = get_duckdb_conn()

    relational_api_table = duckdb_conn.table("relational_api_members")

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyConnection,
        member_list=CREATION_MEMBER_LIST,
        section="Relation Creation",
    )

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=DEFINITION_MEMBER_LIST,
        section="Relation Definition Details",
    )

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=TRANSFORMATION_MEMBER_LIST,
        section="Transformation",
    )
    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=FUNCTION_MEMBER_LIST,
        section="Functions",
    )

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=OUTPUT_MEMBER_LIST,
        section="Output",
    )

    generate_from_db(relational_api_table)


if __name__ == "__main__":
    main()
