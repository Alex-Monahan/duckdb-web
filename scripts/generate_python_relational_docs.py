import duckdb

import inspect

import warnings

FORMATTER_TEXT = """---
layout: docu
redirect_from:
- /docs/api/python/relational_api
- /docs/api/python/relational_api/
- /docs/clients/python/relational_api
title: Relational API
---

<!-- Generated by scripts/generate_python_relational_docs.py -->

"""

DEFINITION_MEMBER_LIST = [
    "columns",
    "describe",
    "description",
    "dtypes",
    "explain",
    "query",
    "set_alias",
    "alias",
    "shape",
    "show",
    "sql_query",
    "type",
    "types",
]
TRANSFORMATION_MEMBER_LIST = [
    "aggregate",
    "apply",
    "cross",
    "except_",
    "filter",
    "insert",
    "insert_into",
    "intersect",
    "join",
    "limit",
    "map",
    "order",
    "project",
    "select",
    "sort",
    "union",
    "update",
]
FUNCTION_MEMBER_LIST = [
    "any_value",
    "arg_max",
    "arg_min",
    "avg",
    "bit_and",
    "bit_or",
    "bit_xor",
    "bitstring_agg",
    "bool_and",
    "bool_or",
    "count",
    "cume_dist",
    "dense_rank",
    "distinct",
    "favg",
    "first",
    "first_value",
    "fsum",
    "geomean",
    "histogram",
    "lag",
    "last",
    "last_value",
    "lead",
    "list",
    "max",
    "mean",
    "median",
    "min",
    "mode",
    "n_tile",
    "nth_value",
    "percent_rank",
    "product",
    "quantile",
    "quantile_cont",
    "quantile_disc",
    "rank",
    "rank_dense",
    "row_number",
    "select_dtypes",
    "select_types",
    "std",
    "stddev",
    "stddev_pop",
    "stddev_samp",
    "string_agg",
    "sum",
    "unique",
    "value_counts",
    "var",
    "var_pop",
    "var_samp",
    "variance",
]
OUTPUT_MEMBER_LIST = [
    "arrow",
    "close",
    "create",
    "create_view",
    "df",
    "execute",
    "fetch_arrow_reader",
    "fetch_arrow_table",
    "fetch_df_chunk",
    "fetchall",
    "fetchdf",
    "fetchmany",
    "fetchnumpy",
    "fetchone",
    "pl",
    "record_batch",
    "tf",
    "to_arrow_table",
    "to_csv",
    "to_df",
    "to_parquet",
    "to_table",
    "to_view",
    "torch",
    "write_csv",
    "write_parquet",
]

CREATION_MEMBER_LIST = [
    'from_arrow',
    'from_csv_auto',
    'from_df',
    'from_parquet',
    'from_query',
    'query',
    'read_csv',
    'read_json',
    'read_parquet',
    'sql',
    'table',
    'table_function',
    'values',
    'view',
]

SECTION_MAP = {
    "Relation Creation": {
        "id": 1,
        "description": "This section contains the details on how a relation is created.",
    },
    "Relation Definition Details": {
        "id": 2,
        "description": "This section contains the details on how to inspect a relation.",
    },
    "Transformation": {
        "id": 3,
        "description": "This section contains the methods which can be used to chain queries.\
        The transformation methods are lazy evaluated, therefore not executed.\
        The execution happens at [output](#output) or [function](#functions) call.",
    },
    "Functions": {
        "id": 4,
        "description": "This section contains the functions which can be applied to an relation, \
        in order to get a (scalar) result. When a function is called the SQL is executed.",
    },
    "Output": {
        "id": 5,
        "description": "This section contains the functions which will trigger an SQL execution and retrieve the data.",
    },
}


DEFAULT_EXAMPLE = '''```python
import duckdb

duckdb_conn = duckdb.connect()

rel = duckdb_conn.sql("""
        SELECT 
            gen_random_uuid() as id, 
            range as value, 
            now() as created_timestamp
        FROM range(1, 10)
    """
)

{code_example}
```
'''

DEFAULT_RESULT = "```text\n{result}\n```"

DEFAULT_CODE_EXAMPLE_MAP = {
    'columns': {
        'example': 'rel.columns',
        'result': "['id', 'value', 'created_timestamp']",
    },
    'describe': {
        'example': 'rel.describe()',
        'result': """
┌─────────┬──────────────────────────────────────┬────────────────────┬────────────────────────────┐
│  aggr   │                  id                  │       value        │     created_timestamp      │
│ varchar │               varchar                │       double       │          varchar           │
├─────────┼──────────────────────────────────────┼────────────────────┼────────────────────────────┤
│ count   │ 9                                    │                9.0 │ 9                          │
│ mean    │ NULL                                 │                5.0 │ NULL                       │
│ stddev  │ NULL                                 │ 2.7386127875258306 │ NULL                       │
│ min     │ 15773c59-febd-4f63-b4e2-554d71dc6f33 │                1.0 │ 2025-04-09 13:42:27.506+02 │
│ max     │ edc5c577-b5a1-4ce1-9011-f559ff7e5ee5 │                9.0 │ 2025-04-09 13:42:27.506+02 │
│ median  │ NULL                                 │                5.0 │ NULL                       │
└─────────┴──────────────────────────────────────┴────────────────────┴────────────────────────────┘    
""",
    },
    'description': {
        'example': 'rel.description',
        'result': """
[('id', 'UUID', None, None, None, None, None),
 ('value', 'NUMBER', None, None, None, None, None),
 ('created_timestamp', 'DATETIME', None, None, None, None, None)]    
""",
    },
    'dtypes': {
        'example': 'rel.dtypes',
        'result': '[UUID, BIGINT, TIMESTAMP WITH TIME ZONE]',
    },
    'explain': {
        'example': 'rel.explain()',
        'result': """
'┌───────────────────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│             id            │\n│           value           │\n│     created_timestamp     │\n│                           │\n│          ~9 Rows          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│           RANGE           │\n│    ────────────────────   │\n│      Function: RANGE      │\n│                           │\n│          ~9 Rows          │\n└───────────────────────────┘\n\n'
""",
    },
    'set_alias': {
        'example': "rel.set_alias('abc').select('abc.id')",
        'result': 'In the SQL query, the alias will be `abc`',
    },
    'alias': {'example': 'rel.alias', 'result': 'unnamed_relation_43c808c247431be5'},
    'shape': {'example': 'rel.shape', 'result': '(9, 3)'},
    'show': {
        'example': 'rel.show()',
        'result': """
┌──────────────────────────────────────┬───────┬───────────────────────────┐
│                  id                  │ value │     created_timestamp     │
│                 uuid                 │ int64 │ timestamp with time zone  │
├──────────────────────────────────────┼───────┼───────────────────────────┤
│ 1481d107-30e1-47b4-a766-43b4c63abf55 │     1 │ 2025-04-09 13:42:21.35+02 │
│ 7d7ce3e3-368f-4c17-b078-f2d88de99d31 │     2 │ 2025-04-09 13:42:21.35+02 │
│ d581a6ac-fbdc-4ccf-9b6f-9dad7634b856 │     3 │ 2025-04-09 13:42:21.35+02 │
│ d00cb553-a4e0-433d-b5cc-72fde3a6941c │     4 │ 2025-04-09 13:42:21.35+02 │
│ 3cfceb8a-63c9-4fb3-ae25-cd7301be65dd │     5 │ 2025-04-09 13:42:21.35+02 │
│ 17d8c119-43b3-4531-990f-55836f54386f │     6 │ 2025-04-09 13:42:21.35+02 │
│ 665ef1c4-fa48-4fbd-b832-19734e37f1ef │     7 │ 2025-04-09 13:42:21.35+02 │
│ af9c67fe-f67f-48b2-83f4-1e31d5dc1885 │     8 │ 2025-04-09 13:42:21.35+02 │
│ 964af6cc-9da1-456d-bc81-10b486f8fbc6 │     9 │ 2025-04-09 13:42:21.35+02 │
└──────────────────────────────────────┴───────┴───────────────────────────┘
""",
    },
    'sql_query': {
        'example': 'rel.sql_query()',
        'result': 'SELECT gen_random_uuid() AS id, "range" AS "value", now() AS created_timestamp FROM "range"(1, 10)',
    },
    'type': {'example': 'rel.type', 'result': 'QUERY_RELATION'},
    'types': {
        'example': 'rel.types',
        'result': '[UUID, BIGINT, TIMESTAMP WITH TIME ZONE]',
    },
    "aggregate": {
        "example": "print(rel.aggregate('max(value)'))",
        "result": """
┌──────────────┐
│ max("value") │
│    int64     │
├──────────────┤
│            9 │
└──────────────┘
        """,
    },
}


def get_duckdb_conn():
    duckdb_conn = duckdb.connect()
    duckdb_conn.sql(
        """
        CREATE TABLE relational_api_members(
            class_name text,
            member_name text,
            section text,
            section_id integer,
            member_signature text,
            member_description text,
            member_toc_line text,
            member_example text,
            member_result text,
            primary key (class_name, member_name)
        )
    """
    )
    return duckdb_conn


def populate_member_details(relational_api_table, class_name, member_list, section):

    for class_member in inspect.getmembers(class_name):
        class_member_name = class_member[0]
        class_member_value = class_member[1]
        if class_member_name not in member_list:
            continue
        member_signature = None
        member_description = None
        if inspect.getdoc(class_member_value):
            member_docs = inspect.getdoc(class_member_value).split("\n\n")
            if len(member_docs) >= 2:
                member_signature = member_docs[0]
                member_description = '\n'.join(member_docs[1:])
            else:
                member_description = member_docs[0]

            if class_member_name in ['from_parquet', 'read_parquet']:
                member_description = "Create a relation object from the Parquet files"

        relational_api_table.insert(
            [
                class_name.__name__,
                class_member_name,
                section,
                SECTION_MAP.get(section).get("id"),
                f"```python\n {member_signature}\n```" if member_signature else None,
                member_description,
                f"| [`{class_member_name}`](#{class_member_name}) | {member_description} |",
                (
                    DEFAULT_EXAMPLE.format(
                        code_example=DEFAULT_CODE_EXAMPLE_MAP.get(
                            class_member_name
                        ).get("example")
                    )
                    if DEFAULT_CODE_EXAMPLE_MAP.get(class_member_name)
                    else None
                ),
                (
                    DEFAULT_RESULT.format(
                        result=DEFAULT_CODE_EXAMPLE_MAP.get(class_member_name).get(
                            "result"
                        )
                    )
                    if DEFAULT_CODE_EXAMPLE_MAP.get(class_member_name)
                    else None
                ),
            ]
        )


def generate_from_db(relational_api_table):
    with open("docs/stable/clients/python/relational_api.md", "w") as f:
        f.write(FORMATTER_TEXT)
        f.write("\n")

        # write TOC
        f.write("## Index")

        toc_section = (
            relational_api_table.select('section', "section_id", 'member_toc_line')
            .string_agg(
                'member_toc_line',
                sep='\n',
                groups='section, section_id',
                projected_columns='section, section_id',
            )
            .order("section_id")
        )

        for section in toc_section.fetchall():
            f.write(
                f"\n\n**[{section[0]}](#{section[0].lower().replace(" ", "-")})**\n\n"
            )
            f.write("| Name | Description |\n|:--|:-------|\n")
            f.write(section[2])

        f.write("\n\n")

        # write section details
        section_details = (
            relational_api_table.select(
                """
            section,
            section_id,
            concat('### ',member_name) as header_member_name, 
            case when member_signature is not null then '\n\n#### Signature\n\n' else NULL end as header_signature, 
            member_signature,
            case when member_description is not null then '\n\n#### Description\n\n' else NULL end as header_description, 
            member_description,
            case when member_example is not null then '\n\n##### Example\n\n' else NULL end as header_example,
            member_example,
            case when member_result is not null then '\n\n##### Result\n\n' else NULL end as header_result,
            member_result
        """
            )
            .select(
                """
                section, 
                section_id, 
                concat(
                    header_member_name, 
                    header_description, 
                    member_description, 
                    header_signature, 
                    member_signature, 
                    header_example, 
                    member_example, 
                    header_result, 
                    member_result
                ) as detailed_section
            """
            )
            .string_agg(
                "detailed_section",
                sep='\n\n----\n\n',
                groups='section, section_id',
                projected_columns='section, section_id',
            )
            .order("section_id")
        )

        for section in section_details.fetchall():
            f.write(f"\n\n## {section[0]} \n\n")
            f.write(SECTION_MAP.get(section[0]).get("description"))
            f.write("\n\n")
            f.write(section[2])

        f.write("\n")


def check_fully_documented(class_name, configured_in_script, class_members):
    if too_many_doc_members := list(set(configured_in_script) - set(class_members)):
        warnings.warn(
            f"The following members are not in the {class_name} anymore!: {too_many_doc_members}"
        )
    if undocumented_members := list(set(class_members) - set(configured_in_script)):
        warnings.warn(
            f"There are members which are not documented for {class_name}: {undocumented_members}"
        )


def main():
    check_fully_documented(
        class_name="DuckDBPyRelation",
        configured_in_script=(
            DEFINITION_MEMBER_LIST
            + TRANSFORMATION_MEMBER_LIST
            + FUNCTION_MEMBER_LIST
            + OUTPUT_MEMBER_LIST
        ),
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyRelation)
            if not member[0].startswith("_")
        ],
    )

    check_fully_documented(
        class_name="DuckDBPyConnection",
        configured_in_script=CREATION_MEMBER_LIST,
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyConnection)
            if inspect.getdoc(member[1])
            and '-> duckdb.duckdb.DuckDBPyRelation' in inspect.getdoc(member[1])
        ],
    )

    duckdb_conn = get_duckdb_conn()

    relational_api_table = duckdb_conn.table("relational_api_members")

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyConnection,
        member_list=CREATION_MEMBER_LIST,
        section="Relation Creation",
    )

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=DEFINITION_MEMBER_LIST,
        section="Relation Definition Details",
    )

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=TRANSFORMATION_MEMBER_LIST,
        section="Transformation",
    )
    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=FUNCTION_MEMBER_LIST,
        section="Functions",
    )

    populate_member_details(
        relational_api_table=relational_api_table,
        class_name=duckdb.DuckDBPyRelation,
        member_list=OUTPUT_MEMBER_LIST,
        section="Output",
    )

    generate_from_db(relational_api_table)


if __name__ == "__main__":
    main()
